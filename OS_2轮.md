# **操作系统二轮**

## 1 操作系统概述

### 1.0 考纲内容

* 操作系统的基本概念
* 操作系统的发展历程
* 程序运行环境、cpu运行模式：内核与用户、中断和异常的处理、系统调用、程序的链接装入、程序运行时的内存映像与地址空间
* 操作系统结构-分层、模块化、宏内核、微内核、内核
* 操作系统引导
* 虚拟机

#### 1.1 操作系的基本概念

#### 1.1.1 操作系统的概念

操作系统（Operating System， OS）是指==控制==和==管理==整个计算机系统的==硬件和软件==资源，并合理地组织调度计算机的工作和资源的分配；以==提供给用户和其他软件方便的接口和环境==；它是计算机系统中最基本的==系统软件==。

#### 1.1.2 操作系统的特征

并发、共享、异步、虚拟

* 并发：两个或者多个事件在==同一时间间隔==内发生使得系统具有处理和调度多个程序同时执行的能力操作系统的并发是通过分时实现的（时间片、流水线技术）
* 共享：互斥共享--打印机、同时访问--磁盘
* 虚拟：时分复用、空分复用
* 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，多道程序走走停停，进程以不可预知的速度向前进

![image-20210805094410098](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805094410098.png)

#### 1.1.3 操作系统的功能和目标

1. 操作系统作为系统资源的管理者
2. 操作系统作为用户与计算机硬件系统之间的接口（向上层提供方便易用的服务）
   * ==封装==思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。
3. 操作系统实现了对计算机资源的扩充（最接近硬件的一层软件）
   * 需要实现对==硬件机器的拓展== 没有任何软件支持的计算机称为==裸机==。在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器 通常把覆盖了软件的机器成为==扩充机器==，又称之为==虚拟机==

![image-20210805101358216](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805101358216.png)

### 1.2 操作系统的发展历程

#### 1.2.1 手工操作阶段

该阶段没有操作系统都是人工干预

缺点：

* 用户独占全机，资源利用率低
* cpu等待用户操作，利用不充分

![image-20210805103313437](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805103313437.png)

#### 1.2.2 批处理阶段

为了解决人机之间速率不匹配的矛盾，出现了批处理系统

* 单道批处理系统
  * 为实现对作业的连续处理，需要先将一批作业以脱机方式输入磁带，并且在系统中配上监督程序。内存中始终保持一道作业。

主要特征如下：

* 自动性--无需人工干预，自动逐个执行
* 顺序性--先调入的先执行
* 单道性--内存中仅有一道程序执行

![image-20210805103327096](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805103327096.png)

* 多道批处理系统
  * 用户所提交的作业存放在外村上并排成一个队列，作业调度程序按一定的算法从后备队列中选择若干作业调入内存，在管理程序的控制下相互穿插的运行，共享系统中的各种硬/软件资源。某道程序因请求I/O操作而站厅的时候，cpu就去运行另一道程序，这是通过中断机制实现的。
* 多道程序设计的特点是：微观上串行、宏观上并行
  * 多道--内存中有多道程序
  * 宏观上并行--同时进入系统的多道程序都处于运行过程中，但都未运行完毕
  * 微观上串行--内存中多道程序轮流占有cpu，交替执行
* 多道程序需要解决的问题：
  * 如何分配处理器
  * 多道程序的内存分配问题
  * I/O设备如何分配
  * 如何组织和存放大量的程序和数据，以保证安全性和一致性

优点：

* 资源利用率高
* 系统吞吐量大

缺点：

* 无人机交互能力
* 用户响应时间长

![image-20210805103337476](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805103337476.png)

#### 1.2.3 分时操作系统

计算机以==时间片==为单位==轮流==为各个用户/作业服务，各个用户可通过终端与计算机进行交互。 主要优点：用户请求可以被即时响应，==解决了人机交互问题==。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 主要缺点：==不能优先处理一些紧急任务==。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。

主要特征：

* 同时性：多个终端用户同时使用一台计算机
* 交互性：可以人机交互（参考Linux的terminal）
* 独立性：多个用户彼此独立地进行操作，互不干扰。使用户感觉独占计算机
* 及时性：很短时间内就能响应用户

#### 1.2.4 实时操作系统

![image-20210805104005902](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805104005902.png)

主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且==要在严格的时限内处理完事件==。实时操作系统的主要特点是==及时性和可靠性==

#### 1.2.5 网络操作系统和分布式计算机系统

* 网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）
* 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

![image-20210805104401758](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805104401758.png)

### 1.3 操作系统的运行环境

#### 1.3.1 处理器运行模式

cpu通常执行两种不同性质的程序：

* 操作系统内核程序
* 用户自编程序（系统外层的应用程序，简称应用程序）

​	前者是后者的管理者，因此“管理程序”（内核程序）要执行一些特权指令，但是“app”不能执行特权指令

-----

“指令”就是处理器（CPU）能识别、执行的最基本命令，指==二进制==机器指令

* 特权指令：是指不允许用户直接使用的指令，如I/O指令、关中断指令、内存清零指令、存取用于内存保护的寄存器、送PSW到程序状态字寄存器
* 非特权指令：指用户可以直接使用的指令，它不可以直接访问系统中的软硬件资源，仅限于访问用户的地址空间

**cpu运行模式**--用户态（目态）、核心态（管态、内核态）

处于内核态时，说明此时正在运行的是==内核程序==，此时可以执行==特权指令== 处于用户态时，说明此时正在运行的是==应用程序==，此时只能执行==非特权指令==

内核态--用户态：执行一条==特权指令==——修改==PSW==的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 用户态--内核态：由“==中断==”引发，==硬件自动完成变态过程==，触发中断信号意味着操作系统将强行==夺回==CPU的使用权

1. 时钟管理--通过时钟管理完成进程切换（时间片轮转调度）

2. 中断机制--I/O、进程调度、系统功能的调用、设备驱动、文件访问都离不开中断机制（只有一部分属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序）

3. ==原语==--按层次结构设计的操作系统，底层是一些可以被调用的小程序，各自完成一个规定的操作，这些程序称为原语

   * 操作系统的底层，最接近硬件的部分
   * 这些程序的运行具有原子性，操作只能一气呵成
   * 运行时间短，调用频繁

   定义原语的直接方法是：关中断、完成所有动作不可分割地完成后再打开中断。（系统中地设备驱动、cpu切换、进程通信等功能中地部分操作都可以定义为原语，使他们内核地组成部分）

4. 系统控制的数据结构及处理

   如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表

   基本操作:

   * 进程管理
   * 存储器管理
   * 设备管理

核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令

#### 1.3.2 中断和异常的概念

在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑两种状态之间如何切换。

==操作系统内核工作在核心态==，而==用户程序工作在用户态==。

---

“中断”是让操作系统内核==夺回CPU使用权==的唯一途径

1. 中断和异常的定义

==中断（外中断）==，是指来自cpu执行==指令外部==的事件，通常用于信息输入/输出，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务。

==异常（内中断）==，是指来自cpu执行==指令内部==的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。异常不能被屏蔽，一旦出现，就应立即处理。

![image-20210806093050375](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806093050375.png)

2. 中断和异常的分类

​	外中断可分为可屏蔽中断和不可屏蔽中断。

* 可屏蔽中断是指INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断
* 不可屏蔽中断是指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电

​	异常可以分为故障、自陷和终止

* 故障：由指令执行引起的异常，非法操作码、缺页故障、除数为0、运算溢出
* 自陷：是一种事先安排的“异常“事件，用于用户态下调用操作系统内核程序，如trap指令
* 终止：使得cpu无法继续执行的硬件故障，如控制器出错、存储器校验错

3. 中断和异常的处理过程

​	当cpu在执行用户程序的第i条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号，则cpu打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，cpu执行中断或者异常返回指令，回到第i条或第i+1条指令继续执行；若中断或者异常处理程序发现是不可恢复的致命错误，则终止应用程序。

#### 1.3.3 系统调用

“系统调用”是操作系统==提供给应用程序==（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求==获得操作系统内核==的服务

系统调用的功能：涉及系统资源管理、进程管理

* 设备管理--完成设备的请求/释放/启动
* 文件管理--完成文件的读/写/创建/删除
* 进程控制--完成进程的创建/撤销/阻塞/唤醒
* 进程通信--完成进程之间的消息传递/信号传递
* 内存管理--完成内存的分配/回收

​	系统调用的处理过程：

* 将系统调用号和所需要的参数压入堆栈；调用实际的调用指令，然后执行陷入指令将cpu状态从用户态转为核心态，再后由==硬件和操作系统内核程序保护被中断进程的现场==，具体是将PC、PSW以及通用寄存器内容等压入堆栈
* 分析系统调用类型，转入相应的系统调用处理子程序（根据系统调用入口表）
* 在系统调用处理子程序执行结束后，恢复被中断的或者设置新进程的cpu现场，然后返回被中断进程或新进程

![1](https://tse4.mm.bing.net/th/id/OIP.qLmnWO04mS73cFTYNI2stAHaCv?rs=1&pid=ImgDetMain)

---

用户态转为核心态

* 用户程序要求操作系统的服务--系统调用
* 发生一次中断
* 用户程序产生了一个错误状态
* 用户程序中企图执行一条特权指令

核心态转为用户态

* 一条特权指令，一般是中断返回指令

### 1.4 操作系统结构

1. 分层法

​	将操作系统分为若干层，底层（层0）为硬件层，顶层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单项依赖）

优点：

* 便于系统的调试和验证，简化了系统的设计和实现
* 易于扩充和易维护

问题：

* 合理定义各层比较困难
* 效率较差

2. 模块化

将操作系统按照功能划分为若干具有一定的独立性的模块，每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好子模块之间的接口

优点：

* 提高了操作系统设计的正确性、可理解性和可维护性
* 增强了操作系统的可适应性
* 加速了操作系统的开发过程

缺点：

* 模块间的接口规定很难满足对接口的实际需求

3. 宏内核（单内核、大内核）--Linux、unix

​	将OS的主要功能模块都作为系统内核，运行在核心态，通常也采用了“模块化”的思想

- 优点：性能高，内核内部各种功能都可以直接相互调用
- 缺点：
  - 内核庞大功能复杂，难以维护
  - 大内核中某个功能模块出错，就可能导致整个系统崩溃

4. 微内核--Windous NT

​	只把中断、原语、进程通信等最核心的功能放入内核，进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态

​	微内核将操作系统划分为两大部分：微内核和多个服务器

​	微内核包括：与硬件紧密相关的、一些基本功能、客户与服务器之间的通信

* 微内核基本功能：

  * 进程/线程管理

  * 低级存储器管理

  * 中断和陷入处理

* 特点

  * 扩展性和灵活性
  * 可靠性和安全性
  * 可移植性
  * 分布式计算

---

* 优点：

  - 内核小功能少、易于维护，内核可靠性高

  - 内核外的某个功能模块出错不会导致整个系统崩溃

- 缺点：
  - 性能低，需要频繁地在核心态/用户态之间切换
  - 用户态下的各功能模块不可直接相互调用，只能通过内核的“消息传递”间接通信

5. 外核

​	内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全
优点：

* 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源
* 减少了虚拟硬件资源的“映射层”，提升效率

缺点：

* 降低了系统的一致性
* 使系统变得更复杂

![image-20210806095502046](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806095502046.png)

### 1.5 操作系统引导

* ==激活cpu==--激活的cpu读取ROM中的boot程序，将指令寄存器置为BIOS的第一条指令（开始执行BIOS的指令）
* 硬件自检--BIOS程序在内存最开始的空间构建中断向量表，接下来的POST过程要用到中断功能

* ==加载带有操作系统的硬盘==。通电自检后，BIOS开始读取Boot Sequence（通过CMOS里保存的 启动程序，或者通过与用户交互的方式），将控制权交给启动顺序排在第一位的存储设备，然后cpu将该存储设备引导扇区的内容加载到内存中

* ==加载主引导记录（MBR）==。硬盘以特定的标识符区分引导硬盘和非引导硬盘，MBR的作用是告诉cpu去硬盘的哪个主分区去找操作系统。
* ==扫描硬盘分区表==，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区--有操作系统的分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。
* ==加载分区引导记录（PBR）==。读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并己获分区根目录下用于引导操作系统的程序（启动管理器）
* 加载启动管理器
* 加载操作系统

​	MBR是磁盘的第一个扇区、它不属于任何的磁盘分区；而PBR位于磁盘活动分区的第一个扇区。

### 1.6 虚拟机

#### 1.6.1 虚拟机的基本概念

* 第一类虚拟机管理程序

​	这个就像操作系统，它是唯一一个运行在最高特权级的程序。他在裸机上运行并且具备

多道程序功能，该管理程序向上提供若干虚拟机，可以运行不同的操作系统。

​	虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统任务自己运行在内核态，实际上是虚拟内核态。==当虚拟机执行了一条cpu处于内核态才能执行的指令时，会陷入虚拟机管理程序。==在支持虚拟化的cpu上，虚拟机管理程序检查这条指令是由虚拟机虚拟机中的操作系统执行还是由用户程序执行。前者--安排这条指令的正确执行；后者--模拟硬件面对用户态执行敏感指令时的行为。

* 第二类虚拟机管理程序

​	就是VMware之类的虚拟机程序，该管理程序运行在宿主操作系统之上，管理客户操作系统

## 2 进程

### 2.0 考纲内容

* 进程和线程
  * 基本概念、状态与转换、线程的实现、内核支持的线程、线程库支持的线程、进程和线程的组织与控制、进程间通信：共享内存、消息传递、管道
* cpu调度与上下文切换
  * 调度的基本概念；目标；调度的实现：调度器/调度程序，调度的时机与调度方式（抢占式/非抢占式），闲逛进程，内核级线程与用户级线程调度
  * 典型调度算法
  * 上下文切换及其机制
* 同步和互斥
  * 同步与互斥的基本概念
  * 基本的实现方法：软件方法、硬件方法
  * 锁：信号量、条件变量
  * 经典同步问题：生产者-消费者；读者-写者，哲学家进餐
* 死锁
  * 死锁的基本概念；死锁预防
  * 死锁避免；死锁检测和解除

### 2.1 进程与线程

#### 2.1.1 进程的概念和特征

1. 进程的概念

​	多道程序环境下，运行多个程序并发执行，此时失去了封闭性，并具有间断性及不可再现性的特征。

​	==进程实体（进程映像）==由程序段、相关数据段、PCB构成

​	当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— ==PID==（Process ID，进程ID）

​	这些信息都被保存在一个数据结构==PCB==（Process Control Block）中，即==进程控制块==操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中

* 进程的定义：进程实体的运行过程，是系统进行资源分配和调度的一个独立单位；==程序的一次执行过程==；同一个程序多次执行会对应多个进程

2. 进程的特征

* 动态性--进程是程序的一次执行，有着创建、活动、暂停、终止等过程，具有一定生命周期，是==最基本的特征==
* 并发性--指多个进程同存于内存中，一段时间内同时运行
* 独立性--进程是一个能独立运行、独立获得资源和接受调度的基本单位
* 异步性--进程间的相互制约，使得各进程按各自独立的、不可预知的速度向前推进，会导致结果的不可再现性

#### 2.1.2 进程的组成

![image-20210806102114288](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806102114288.png)

PCB常驻内存，任意时刻都可以存取，并且在进程结束时删除。PCB是进程实体的一部分，是进程存在的==唯一标志==

![image-20210806102043843](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806102043843.png)

注：

* 进程控制和管理信息还包括：进程优先级--描述进程抢占cpu的优先级，优先级高的进程可先获得cpu
* 处理机相关信息（cpu的上下文）：主要指cpu中各寄存器的值

#### 2.1.3 进程的状态与转换

![image-20210806104039442](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806104039442.png)

注：运行态到阻塞态是主动行为；阻塞态到就绪态是被动的

#### 2.1.4 进程控制

==进程控制就是要实现进程状态转换==

- 如何实现==进程控制==？

  用“==原语==”实现

  原语的执行具有“原子性”，一气呵成

- 如何实现原语的“原子性”？

  原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性

1. 进程的创建

​	允许一个进程创建另一个进程，子进程可以继承父进程所拥有的资源，子进程被撤销的时候，应将其从父进程那里获得的资源还给父进程。撤销父进程，子进程也会撤销。

​	事件：用户登录，作业调度，提供服务，应用请求

​	创建时的操作：分配PID，申请一个空白PCB；为进程分配其运行所需要的资源（文件、内存、I/O设备、cpu时间）（如果资源不足，就会在创建态等等待内存资源）；初始化PCB；若进程就绪队列能够接纳新进程，调入就绪队列

2. 进程的终止

​	事件：正常结束、异常结束、外界干预

​	终止进程的过程：根据PID检索PCB，读出进程状态；若被终止进程处于运行状态，立刻终止该进程的执行，将cpu资源分配给其他进程；如果还有子孙进程，通常需要终止子孙进程；将进程所拥有的全部资源归还给父进程或操作系统；将PCB从队列中删除

3. 进程的阻塞和唤醒

* 阻塞态（block）是==暂时==停止运行，比如等待IO操作，等待其他进程配合
  * 根据PID找到PCB；如果是运行态，就保护现场，转为阻塞态，停止运行；PCB插入相应事件的等待队列，将PCB资源给其他就绪进程

* 唤醒（wake up）是等待的事件发生就从阻塞到就绪态
  * 找到PCB，移除等待队列置为就绪态；插入就绪队列等待调度

#### 2.1.5 进程的通信

![image-20210809091958835](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809091958835.png)

进程通信就是指进程之间的==信息交换==。 进程是分配系统资源的单位（包括内存地址空间），因此==各进程==拥有的==内存地址空间相互独立==。

为了保证安全，==一个进程不能直接访问另一个进程的地址空间==。

* **共享存储**

==基于数据结构==的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式 ==基于存储区==的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

* **管道通信**

数据以字符流的形式写入管道，当管道==写满==时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部==取走后==，管道==变空==，此时读进程的read（）系统调用将被阻塞。

如果==没写满，就不允许读==。如果==没读空，就不允许写==。

数据==一旦被读出，就从管道中被抛弃==，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

* **消息传递**

进程间的数据交换以==格式化的消息==（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个==原语==进行数据交换。

间接通信：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。

#### 2.1.6 线程和多线程模型

1. 线程的基本概念

​	可以把线程理解为“==轻量级进程==”。 线程是一个==基本的CPU执行单元==，也是==程序执行流的最小单位==。

* 引入线程之后，不仅是进程之间可以并发，==进程内的各线程之间也可以并发==，从而进一步提升了系统的==并发度==，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）

* 引入线程后，==进程==只作为除CPU之外的==系统资源的分配单元==（如打印机、内存地址空间等都是分配给进程的）。==线程==则作为==处理机的分配单元==。

2. 进程和线程的比较

* 调度--传统的操作系统中，拥有资源和独立调度的基本单位都是进程；但是引入线程之后，线程是独立调度的基本单位（线程切换的代价远远低于进程）
* 并发性--在引入线程的操作系统，不仅进程之间可以并发执行，而且一个进程中的多个进程之间亦可并发执行，甚至不同进程的线程也可以并发执行，OS的吞吐量大大提高
* 拥有资源--==进程是拥有资源的基本单位，线程不拥有资源，但是它可以访问其隶属进程的系统资源==（同一进程的所有线程具有相同的地址空间）
* 独立性--进程都拥有独立的地址空间和资源，除了全局变量可之外，其他不允许其他进程访问；某个进程的线程对其他进程不可见
* 系统开销--在创建或者撤销进程时，系统会分配或者回收PCB和其他资源，但是线程切换只用保存少量的寄存器内容，开销很小
* 支持多处理器系统，多线程进程可以将多个线程分配到多个cpu上

3. 线程的属性

* 线程时一个轻型实体，不拥有系统资源，但是它具有一个唯一的标识符和线程控制块
* 不同的线程可以执行相同的程序，同一个服务程序被不同的用户调用时。OS将它们创建成不同的线程
* 同一进程的各个线程共享该进程所拥有的资源
* 线程是cpu的独立调度单位，多个线程可以并发执行，在单cpu的计算机系统中，各线程可以交替地占用cpu；多cpu的计算机系统中，各个线程可以同时占用不同的cpu
* 线程也具有就绪、阻塞、运行等状态

![image-20210809092934133](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809092934133.png)

4. 线程的状态和转换

​	执行、就绪、阻塞

5. 线程的状态与转换

* 线程控制块（TCB）--包括线程标识符、一组寄存器（PC、PSW、通用寄存器）、线程运行状态、优先级、线程专有存储区（切换时用于保存线程）、堆栈指针

![1](https://i-blog.csdnimg.cn/direct/631dc09adfa14c93a0f3780a854bd902.png)

* 线程的创建--也具有生命周期，用户程序启动时，通常由初始化线程来创建新线程
* 线程的终止--当一个线程完成自己的任务后，或线程运行出现异常，由终止线程调用相应函数执行终止操作（系统线程不会被终止）==被终止但尚未释放资源的线程任可以被其他线程调用==

6. 线程的实现方式

![image-20210809093107295](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809093107295.png)

==内核级线程才是处理机分配的单位==

### 2.2 cpu调度

#### 2.2.1 调度的概念

1. 调度的基本概念--合理的对进程进行处理及分配

2. 调度的层次

* 高级调度（作业调度）

​	按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业==只调入一次，调出一次==。作业调入时会建立PCB，调出时才撤销PCB。

* 中级调度（内存调度）

​	按照某种策略决定将哪个处于挂起状态的进程==重新调入内存==。 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

* 低级调度（进程调度/处理机调度）

​	按照某种策略从==就绪队列==中选取一个进程，将处理机分配给它。

​	进程调度是操作系统中==最基本的一种调度==，在一般的操作系统中都必须配置进程调度。 进程调度的==频率很高==，一般几十毫秒一次。

3. 三级调度的联系

![image-20210809095221730](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809095221730.png)

注：进程的七状态模型

![image-20210809095100142](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809095100142.png)

==挂起是将进程映像调到外存中==

#### 2.2.2 调度的实现

1. 调度程序（调度器）由三部分组成：排队器、分派器、上下文切换器
   * 排队器--所有就绪进程按照一定的策略排成一个或多个队列
   * 分派器--依据调度程序所选进程从就绪队列取出并且分配cpu
   * 上下文切换器--对cpu进行切换时，保存当前进程的上下文；装入分派程序的上下文；移除分配程序上下文，将新进程的cpu现场信息装入cpu的各个相应寄存器

2. 调度的时机、切换和过程

​	==调度程序是操作系统内核程序==，只有请求调度的事件发生后，才可能运行调度程序，调度了新的就绪进程后，才会进行进程切换

* 进行进程调度与切换的情况

  * 当前运行的进程==主动放弃==处理机
    - 进程正常终止
    - 运行过程中发生异常而终止
    - 进程主动请求阻塞（如等待I/O）

  * 当前运行的进程==被动放弃==处理机
    - 分给进程的时间片用完
    - 有更紧急的事需要处理（如I/O中断）
    - 有更高优先级的进程进入就绪队列

​	进程切换往往在调度完成后立刻发生，他要求保存原进程当前断点的现场信息，恢复被调度进程的现场信息。

* 不能切换的情况

  1. 在==处理中断==的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
  2. 进程在==操作系统内核程序临界区==中。
  3. 在==原子操作过程==中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）

  ![image-20210809095522536](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809095522536.png)

3. 进程调度的方式

* ==非剥夺调度方式==，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

* ==剥夺调度方式==，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

4. 闲逛进程

​	PID为0，如果没有其他进程就绪，该进程就会一直运行，并在指令周期后测试中断。

5. 两种线程的调度

* 用户级--内核选择一个进程，进程中的调度程序决定哪个决定哪个线程运行
* 内核级--内核选择一个特定线程运行

​	用户级线程的线程切换在同一进程中进行，仅需要少量的机器指令；内核级线程的线程切换需要完整的上下文切换、修改内存映像

#### 2.2.3 调度的目标

![image-20210809100430643](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809100430643.png)

* ==周转时间==：指从作业提交到作业完成经历的时间（作业等待、在就绪队列中排队、在cpu上运行以及I/O操作的时间总和

  周转时间=作业完成时间-作业提交时间

  平均周转时间=（作业1的周转时间+…作业n的周转时间）/ n

  带权周转时间是指作业周转时间与作业实际运行时间的比值

#### 2.2.4 进程切换

​	==进程切换==是指一个进程让出处理机，由另一个进程占用处理机的过程。

​	==狭义的进程调度==指的是从就绪队列中选中一个要运行的进程。

​	==广义的进程调度==包含了==选择一个进程==和==进程切换==两个步骤。

1. 上下文的切换

* 切换cpu到另一个进程需要保存当前进程状态并恢复另一个进程的状态。进程上下文采用==PCB==表示，包括寄存器的值、进程状态和内存管理信息

​	切换流程：

* 挂起一个进程，将cpu上下文保存到PCB
* 将进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
* 选择另一个进程执行，并更新PCB
* 恢复新进程的CPU上下文
* 跳转到新进程PCB中的程序计数器所指向的位置执行

2. 上下文切换的消耗--消耗很多，但是CPU有多个寄存器组，切换就只用简单改变当前寄存器组的指针
3. 上下文切换和模式切换

​	模式切换--==是用户态和内核态的切换==，cpu可能在逻辑还在执行同一进程

​	==上下文切换==一定发生在内核态

#### 2.2.5 调度算法

* 先来先服务算法（FCFS）

![image-20210809100556385](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809100556385.png)

* 短作业优先（SJF）

![image-20210809103954401](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809103954401.png)

* 高响应比优先（HRRN）

![image-20210809104030359](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809104030359.png)

* 优先级调度算法

![image-20210809104608636](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809104608636.png)

​	优先级设置原则：（有静态和动态之分）

​	系统进程>用户进程

​	交互型>非交互型

​	I/O型>计算型

* 时间片轮转（RR）

![image-20210809104546611](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809104546611.png)

* 多级反馈队列调度算法

![image-20210809104623466](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809104623466.png)

* ==总结==

![1](https://i-blog.csdnimg.cn/direct/afc8d2a13c664bf48703431ef3744e43.png)

![1](https://i-blog.csdnimg.cn/direct/d8158fc1f6384575929104855e0701fe.png)

### 2.3 同步、互斥

#### 2.3.1 基本概念

* 进程同步

​	同步亦称==直接制约关系==，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的==工作次序==而产生的==制约关系==。

​	理解：输入进程A通过<u>单缓冲</u>向进程B提供数据，缓冲区为空，进程B只有在A输入数据后才能获得，进程A只有在B取走数据后才能输入

* 进程互斥

​	==间接制约关系==。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待

* 临界资源--一次仅允许一个进程使用的资源，因此对于临界资源的访问必须互斥地进行，访问临界资源的代码称为==临界区==

​	==临界资源的访问分为四个过程--进入区、临界区、退出区、剩余区==（进入、退出实现互斥）

​	临界区：访问临界资源的那段代码

​	进入区：负责检查是否可进入临界区

​	退出区：负责解除正在访问临界资源的标志

​	剩余区：做其他处理

* ==同步机制要遵循的原则==
  * 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
  * 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
  * 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
  * 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

#### 2.3.2 实现临界区互斥的基本方法

1. 软件实现方法

​	进入区设置并检查一些==标志==来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/52f8755dfd0a415e7f2c12bdd272589d.png)

* 单标志法（我想进！）

​	算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予

```c
P0{
	while(turn != 0); //进入区
	临界区资源; //临界区
	turn = 1; //退出区
}

P1{
	while(turn != 1); //进入区
	临界区资源; //临界区
	turn = 0; //退出区
}
```

​	缺点：

1. 无法完成多个进程互斥
2. ==违背空闲让进==--两个进程必须交替进入临界区，若P1进入临界区并退出将turn=0，之后P0一直未进入临界区，那么由于turn1!=1,所以P1再次向进入临界区的时候就会被一直阻塞。

* 双标志先检查法（你想进不？我想进！）

​	算法思想：设置一个布尔型数组flag[2]，数组中各个元素用来标记各进程想进入临界区的意愿，flag[i]=true表示P~i~想进入临界区（i=0或1）。P~i~进入临界区之前，先检查对方是否想要进入临界区，若想，则等待；否则，将flag[i]设为true后，再进入临界区，退出后将flag[i]置为false

```c
P0{
	while(flag[1]);  //进入区 你想进不？
	flag[0] = true; //进入区 我想进！
	临界区资源；//临界区
	flag[0] = flase; //退出区
}

P1{
	while(flag[0]);  //进入区
	flag[1] = true; //进入区
	临界区资源；//临界区
	flag[0] = flase; //退出区
}
```

![1](D:/learn/408_review/img/img1.png)

优点：

​	不用交替进入，可以连续使用

缺点：

​	p~0~和P~1~可能同时进入临界区；并且在检查对方表之后和设置自己的标志前可能发生进程切换，结果双方都检查通过，会同时进入临界区，==违背了忙则等待==，因为检查和设置操作不是一气呵成的

* 双标志后检查法（我想进！你想进不？）

​	算法思想：先检查法先检查对方的标志，再设置自己的标志，但这两个操作又无法一气呵成，于是使得两个进程同时进入临界区的问题。因此，想到先设置后检查法，以避免上述问题。后检查法先设置自己的标志，再检查对方的标志，若对方的标志为true,则等待；否则，进入临界区。

```c
P0{
	flag[0] = true; //进入区 我想进！
	while(flag[1]);  //进入区 你想进不？
	临界区资源；//临界区
	flag[0] = flase; //退出区
}

P1{
	flag[1] = true; //进入区
	while(flag[0]);  //进入区
	临界区资源；//临界区
	flag[0] = flase; //退出区
}
```

缺点：

​	违背了==空闲让进、有限等待==

* Peterson算法（我想进！你先进吧~）

​	算法思想：Peterson 算法结合了算法一和算法三的思想，利用flag[]解决互斥访问问题，而利用 turn解决“饥饿”问题。若双方都争着进入临界区，则可让进程将进入临界区的机会谦让给对方。也就是说，在每个进程进入临界区之前，先设置自己的flag标志，再设置允许进入turn标志；之后，再同时检测对方的flag和turn标志，以保证双方同时要求进入临界区时，只允许一个进程进入。

```c
P0{
	flag[0] = true; //进入区 我想进
	turn = 1； //进入区 你先进吧
	while(turn == 1 && flag[1] == true); //进入区 你先进吧
	临界区资源； //临界区
	flag[0] = false; //退出区
}

P1{
	flag[1] = true; //进入区 我想进
	turn = 0； //进入区 你先进吧
	while(turn == 0 && flag[0] == true); //进入区 你先进吧
	临界区资源； //临界区
	flag[1] = false; //退出区
}
```

缺点：

​	违背==让权等待==

2. 硬件实现方法

* 中断屏蔽方法

​	利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）==cpu只有在发生中断时引起进程切换==

​	优点：简单、高效 

​	缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令 只能运行在内核态，这组指令如果能让用户随意使用会很危险）

* 硬件指令方法--TestAndSet指令（TS）

```c
boolean TestAndSet(boolean *lock)
{
    boolean old;
    old = *lock; //old用来存放lock旧值
    *lock = true; //无论是否加锁，都将lock设置为true
    return old;  //返回lock旧值
}
```

思想：进程在进入临界区之前，先用TS指令检查lock值：若为false，表示没用进程在临界区可以进入并上锁；若为true，表示临界区有进程，进入循环等待，直到解锁

```c
while TestAndSet(&lock) //加锁并检查
    
lock = false; //解锁

```

优点：

​	实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于==多处理机环境==

缺点：

​	==不满足“让权等待”原则==，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。

* Swap指令（XCHG）

思想：用Swap指令管理临界区时，为每个临界资源设置一个共享布尔变量lock，初值为false；在每个进程钟设置一个局部布尔变量key，初值为true，用于与lock交换信息。逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变 量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程 对临界区上锁，则可跳出循环，进入临界区。

```c
boolean key = true;
while(key!=false)
    Swap(&lock,&key);
//临界区
lock=false;
```

优点：

​	实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

缺点：

​	不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致饥饿。

#### 2.3.3 互斥锁

![1](https://i-blog.csdnimg.cn/direct/1374710b1eac434d9ce8cad63c41776a.png)

![!](https://i-blog.csdnimg.cn/direct/8f6c3c049920430cb1525975960c2f4a.png)

#### 2.3.4 信号量

==实现进程互斥、同步的方法==

![image-20210810101206955](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210810101206955.png)

==信号量==其实就是一个==变量==，可以用一个信号量来表示系统中==某种资源的数量==

wait、signal 原语常简称为==P、V操作==（来自荷兰语proberen 和verhogen）。因此，做题的时候常把wait（S）、signal（S） 两个操作分别写为P（S）、V（S）

![image-20210811085502606](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811085502606.png)

![image-20210811085204493](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811085204493.png)

- 整型信号量

  - 用一个整数型变量作为信号量，数值表示某种资源数
  - 整型信号量与普通型变量的区别：对信号量只能执行 初始化、P、V三种操作
  - 整型信号量存在的问题：不满足让“权等待”原则

- 记录型信号量🌟🌟🌟

  大题、小题超高频考点——几乎每年必考大题

  - S.value 表示某种资源数，S.L指向等待该资源的队列
  - P 操作中，一定是先S.value–，之后可能需要执行 block 原语——资源不够，主动阻塞
  - V 操作中，一定是先S.value++，之后可能执行 wakeup 原语——唤醒一个阻塞进程
  - 可用记录型信号量实现系统资源的“申请”和“释放”
  - 可以用记录型信号量实现进程互斥、进程同步
  - ⚠️：学会自己推断什么条件下需要执行 block 或 wakeup

* ==利用信号量实现进程同步、互斥、前驱关系==

  - 实现进程互斥
    - 分析问题，确定临界区
    - 设置互斥信号量，初值为1
    - 临界区之前对信号量执行P操作
    - 临界区之后对信号量执行V操作

  ![image-20210811085609021](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811085609021.png)

  - 实现进程同步

    前V后P

    - 分析问题，找出哪里需要实现“一前一后”的同步关系
    - 设置同步信号量，初始值为0
    - 在“前操作”之后执行V操作
    - 在“后操作”之前执行P操作

  ![image-20210811085723623](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811085723623.png)

  - 实现进程的前驱关系

    本质上是多级同步问题

    - 分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题
    - 为每一对前去关系设置同步信号量，初值为0
    - 在每个“前操作”之后执行V操作
    - 在每个“后操作”之前执行P操作

![image-20210811085837013](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811085837013.png)

#### ==2.3.5 经典同步问题==

1. 生产者-消费者问题

![image-20210811090040687](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811090040687.png)

![image-20210811090123901](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811090123901.png)

![image-20210811090143116](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811090143116.png)

会导致：我要放东西通过了，但满了放不进去，去到消费者，但通道被生产者占住了，形成死锁 同步：查看缓存区容量和非空区 互斥：消费者和生产者不能同时使用缓存区

* 多生产者-多消费者

![!](https://i-blog.csdnimg.cn/direct/5598e5d1453f4f5b8dc713d084a6d864.png)

![image-20210811090607292](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811090607292-1628643969247.png)

* 吸烟者问题

![!](https://i-blog.csdnimg.cn/direct/21390cdabb9d4545aab41454f99759aa.png)

![image-20210811090820316](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811090820316.png)

![image-20210811090833274](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811090833274.png)

* 读者-写者

遇到==进程同步问题应参考生产者-消费者问题==；而==进程互斥问题==应参考==读者写者问题==

![!](https://i-blog.csdnimg.cn/direct/6088f54054654808bfdee501d4b22b85.png)

* 哲学家进餐

遇到==一个进程需要同时持有多个临界资源==的情况这种问题，应参考哲学家问题

![1](https://i-blog.csdnimg.cn/direct/fca4c0b459cc4645a4c0165fffbb7931.png)

#### 2.3.6 管程

![image-20210811091411446](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811091411446.png)

解决信号量机制编程麻烦、易出错的问题

* 管程定义：
  * 局部于管程的共享数据结构说明；
  * 对该数据结构进行操作的一组过程（函数）；
  * 对局部于管程的共享数据设置初始值的语句；
  * 管程有一个名字。

- 基本特征
  - 局部于管程的数据只能被局部于管程的过程所访问；
  - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
  - 每次仅允许一个进程在管程内执行某个内部过程。
- 补充
  - 各进程必须互斥访问管程的特性是由编译器实现的
  - 可在管程中设置条件变量及等待/唤醒操作wait()/signal()以解决同步问题

### 2.4 死锁

#### 2.4.1 死锁的概念

1. 定义

​	在并发环境下，各进程因==竞争资源==而造成的一种==互相等待==对方手里的资源，导致各进程都==阻塞==，都无法向前推进的现象，就是“死锁”。发生死锁后若==无外力干涉==，这些进程都将==无法向前推进==。

2. 必要条件

* ==互斥条件==：只有对必须==互斥使用==的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。
*  ==不剥夺条件==：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
*  ==请求和保持条件==：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源==保持不放==。
*  ==循环等待条件==：存在一种进程资源的==循环等待链==，链中的每一个进程已获得的资源同时被下一个进程所请求。

#### 2.4.2 死锁预防

* 破坏互斥条件

​	互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。

​	把只能互斥使用的资源改造为==允许共享使用==，则系统不会进入死锁状态。

​	缺点：并不是所有的资源都可以改造成可共享使用的资源。

* 破坏不剥夺条件

​	不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

​	破坏不剥夺条件：

​	 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。

​	方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）

​	缺点：

1. 实现起来比较==复杂==。
2. 释放已获得的资源可能造成==前一阶段工作的失效==。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
3. 反复地申请和释放资源会增加系统==开销==，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程==饥饿==。

* 破坏请求和保持条件

​	请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

​	可以采用静态分配方法，即进程在运行前==一次申请完==它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

​	缺点： 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成==严重的资源浪费==，资源利用率极低。

​	另外，该策略也有可能导致某些进程==饥饿==。

* 破坏循环等待条件

​	循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

​	可采用顺序资源分配法。首先给系统中的==资源编号==，规定每个进程必须按编号递增的==顺序请求==资源，同类资源（即编号相同的资源）一次申请完。

​	原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

​	该策略的缺点：

1. ==不方便增加新的设备==，因为可能需要重新分配所有的编号；
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致==资源浪费==；
3. 必须按规定次序申请资源，用户==编程麻烦==。

#### 2.4.3 死锁避免

==银行家算法==

#### 2.4.4 死锁的检测和解除

* 检测

![image-20210811095750367](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811095750367.png)

![image-20210811145530489](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811145530489.png)

![image-20210811145650810](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210811145650810.png)

==死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁==

* 解除

​	一旦检测出死锁的发生，就应该立即解除死锁。 补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程解除死锁的主要方法有：

1. 资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
2. 撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。
3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

## 3 内存管理 

### 3.0 考纲内容

* 内存管理基础
  * 内存管理概念、逻辑地址和物理地址空间、地址变换、内存共享、内存保护、内存分配和回收
* 虚拟内存管理
  * 虚拟内存基本概念、请求页式管理、页框分配、页置换算法、内存映射文件、虚拟存储器性能的影响因素和改进方式

### 3.1 内存管理概念

#### 3.1.1 内存管理的基本原理和要求

内存（主存）--程序执行前==需要先放到内存中才能被CPU处理==——缓和CPU与硬盘之间的==速度矛盾==

==内存管理==的主要功能：

* 内存空间的分配和回收
* 地址转换--程序的==逻辑地址==与内存中的物理地址不可能一致，要提供地址转换功能
* 内存空间的扩充--虚拟存储技术从逻辑上扩充内存
* 内存共享--指允许多个进程访问访问内存的同一部分
* 存储保护--保证各个进程在各自的存储空间内运行、互不干扰

1. 程序的链接和装入

​	创建进程首先要将程序和数据装入内存。用户源程序变为可在内存中执行的程序：

* 编译：由编译程序将用户源代码编译成若干目标模块
* 链接：由链接程序将编译后形成的一组目标模块以及他们所需的库函数链接在一起，形成一个完整的装入模块
* 装入：由装入程序将装入模块装入内存运行

![1](https://img-blog.csdnimg.cn/20200909092051851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70)

* ==三种装入方式==
  * 绝对装入--只适用于单道程序环境。如果在编译的时候直到将程序放到内存的哪个位置，则编译程序将产生绝对地址。
  * 可重定位装入--装入时将逻辑地址转换为物理地址
  * 动态重定位装入--运行时将逻辑地址转换为物理地址，需要设置==重定位寄存器==

* ==三种链接方式==
  * 静态链接--装入前链接成一个完整装入模块
  * 装入时动态链接--运行时边装入边链接
  * 运行时动态链接--运行时需要目标模块才装入并链接

2. 逻辑地址和物理地址

​	编译后，每个目标模块都从0号单元开始编址，这称为该目标模块的==相对地址/逻辑地址==，链接程序将各个目标模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的==逻辑地址空间==（虚拟地址空间）

​	进程在运行时，看到的和使用的地址都是==逻辑地址==，不同的进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存不同的位置。

​	==物理地址空间==是指内存中物理单元的集合，是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，即==地址重定位==

​	==逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用==

3. 进程的内存映像

​	当一个程序调入内存运行时，就构成了进程的内存映像，一般有几个要素：

* 代码段：程序的二进制代码，代码段只读，可以被多个进程共享
* 数据段：程序运行时加工处理的对象，包括全局变量和静态变量
* 进程控制块（PCB）：存放在系统区。
* 堆：用来存放动态分配的变量，通过调用malloc函数动态地向高地址分配空间
* 栈：实现函数调用，从用户空间的最大地址往低地址方向增长

![img](https://i-blog.csdnimg.cn/direct/045d69c47b224923be828f3897e68184.jpeg)

![img2.jpg](https://github.com/xiaoliangao/review_408/blob/master/img/img2.jpg?raw=true)

4. 内存保护

* 在cpu中设置上、下限寄存器，存放用户进程在主存中上下限地址，每当cpu要访问一个地址时，分别和两个寄存器的值相比，判断有无越界
* 采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）进行越界检查。

​	重定位寄存器中存放的是进程的==起始物理地址==。界地址寄存器中存放的是进程的==最大逻辑地址==。

![1](https://i-blog.csdnimg.cn/blog_migrate/19887d770cc150a5226731178eb856d4.png)

注：重定位寄存器用来==加==，界地址寄存器是用来==比==，这两个寄存器只有os内核才可以修改其中的值

#### 3.1.2 连续分配方式

1. 单一连续分配

​	内存分为==系统区==和==用户区==，系统区仅供操作系统使用，通常在低地址部分，用户区为用户提供

优点：

* 无须进行内存保护，不会出现越界异常

* 实现简单，==无外部碎片==，采用覆盖技术，不需要额外技术支持

缺点：

* 只适用于==单用户==，单任务的操作系统

* 存在==内部碎片==，存储器==利用率低==

2. 固定分区分配

种类：

​	分区大小相等：用一台计算机去控制多个相同对象的场合，缺乏灵活性

​	分区大小不等：划分为多个较小的分区，适量的中等分区和少量大分区

​	为了便于分配和回收，会建立一张==分区使用表==

优点

* 适用于多道程序的存储，无外部碎片

缺点

* 程序太大，无法放入任何一个分区

* 主存利用率低，存在内部碎片

* 不能实现多进程共享一个主存区

3. 动态分区分配

​	在进程装入内存的时候，==根据内存的大小==动态的建立分区，会设置==空闲分区链（表）==

​	优点：分区大小可以根据进程的实际情况进行分配

​	缺点：存在==外部碎片==，最后导致主存利用率下降――采用==紧凑技术==可以缓解这种缺陷

* 
  * 回收内存分区时，可能遇到四种情况
    - 回收区前有相邻的空闲分区
    - 回收区后有相邻的空闲分区
    - 回收区前、后都有相邻的空闲分区
    - 回收区前、后没有相邻的空闲分区

！！==动态分区分配算法==

* 首次适应算法

​	空闲分区按照地址递增的顺序进行查找，找到==第一个==满足要求的分区进行分配

优点：

​	综合看性能最好。算法开销小，回收分区后一般==不需要==对空闲分区队列==重新排序==

* 最佳适应算法

==	按照容量递增==的顺序进行查找分区，将第一个满足条件的进行分配

优点：

​	可以尽可能多地留下大片的空闲区

缺点：

​	性能较差，产生==最多的外部碎片==，回收分区后可能需要对空闲分区队列==重新排序==

​	每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。

* 最坏适应算法（最大适应算法）

​	空闲分区==按照容量递减==的次序进行查找，第一个满足条件的进行分配

优点：

​	可以==减少难以利用的小碎片==

缺点：

​	导致很快没有较大的内存块，性能很差―==不利于大进程==，算法开销大

* 邻近适应算法（首次适应算法）

​	分配内存时从==上次查找结束==的位置开始继续查找

优点：

​	算法开销小

缺点：

​	会使==高地址的大分区也被用完==

​	导致无论低地址、高地址部分的空闲分区都有==相同的概率==被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用

![1](https://i-blog.csdnimg.cn/direct/2d974dd52fef470f8b238749ef53c2fe.png)

#### 3.1.3 基本分页存储管理

* 分页的思想：将内存空间分为一个个大小相等的分区，每个分区就是一个“页框”（==页框=页帧=内存块=物理块=物理页面==）。每个页框有一个编号，即“页框号”（==页框号=页帧号=内存块号=物理块号=物理页号==），页框号从0开始

* 将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。

​	这种方法的好处：从形式上看，分页的方法类似于固定分区技术，分页不产生外部碎片。块（页面）比分区要小很多，并且<u>进程也按照块划分</u>，进程运行时按块申请主存可用空间并执行。这样只会在最后一个块申请一个主存块空间时，才会产生主存碎片。一般来说，每个进程平均只会产生半个块大小的内部碎片（业内碎片）

1. 分页存储的基本概念

* 页面和页面大小：进程的逻辑地址空间中的每个页面有一个编号，从0开始；内存空间中的每个页框也有一个编号，称为页框号（物理块号），也从0开始。

​	页面大小应该是2的整数次幂，且页面大小应该适中：太小会导致页面数过多，页面会很长导致占用大量内存；太大会导致页内碎片增多，降低内存利用率

* 地址结构——[ 页号|页内偏移量 ]
  * 页号 = 逻辑地址 / 页面大小；页内偏移量 = 逻辑地址 % 页面大小

* 页表
  * 作用：实现从页号到物理块号的地址映射
  * 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成
  * 每个页表项的大小是相同的，页号是“隐含”的
  * i号页表项存放地址 = 页表地址 + i * 页表项大小

2. 基本地址变换机构——可以借助进程的页表将逻辑地址转换为物理地址

​	通常会在系统中设置一个==页表寄存器==（PTR），==存放页表在内存中的起始地址F和页表长度M==。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中

![0](https://i-blog.csdnimg.cn/blog_migrate/a64240afc39172840546e55102ad7726.png)

* 页表长度--指的是这个页表中总共有几个页表项，即总共有几个页；
* 页表项长度--指的是每个页表项占多大的存储空间。
* 页面大小--指的是一个页面占多大的存储空间；

* 地址转换过程：
  * 计算页号P和页内偏移量W
  * 比较页号P和页表长度M，若==P≥M，则产生越界中断==，否则继续执行。
  * 页表中页号P对应的==页表项地址=页表起始地址F + 页号P * 页表项长度==，取出该页表项内容b，即为内存块号。
  * 计算E = b * L + W，用得到的物理地址E去访存。
  * 访问物理内存对应的内存单元。

​	==快表==，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。

![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E5TfRtxj-1675238574999)(images/OS/image-20221017171052535.png)]](https://i-blog.csdnimg.cn/blog_migrate/843071c8cc56c13b2a747bd23d172917.png)

* 具有快表的地址转换过程：
  * CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
  * 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
  * 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

4. 两级页表

- 单机页表存在的问题
  - 所有页表现必须连续存放，页表过大时需要很大的连续空间
  - 在一段时间内并非所有页面都用得到，没必要让整个页表常驻内存
- 两级页表
  - 将长长的页表再分页
  - 逻辑地址结构：(一级页号，二级页号，页内偏移量)
  - 注意几个术语：页目录表/外层页表/顶级页表
- 实现地址变换

![1](https://i-blog.csdnimg.cn/direct/059f68d2973f40a99225b85a1a9e8838.png)

* 几个细节
  - 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级
  - 多级页表的访存次数(假设没有快表机构)——N 级页表访问一个逻辑地址需要 N + 1次访存

#### 3.1.4 基本分段存储管理

1. 分段

​	按照用户进程中的自然段划分逻辑空间

​	地址结构=段号S+段内偏移量w

​	页式系统中，页号和页内偏移对用户透明

​	段式系统中段号和段内偏移量必须由用户显示的提供

2. 段表

​	每个进程都有一张逻辑空间与内存空间映射的段表，这个段表项对应进程的一段，段表项记录该段在内存中的始址和长度

​	==段表内容=段号（隐含）|段长|本段在主存中的地址==

3. 地址变换机构

* 逻辑地址A中取出段号S和段内偏移量w
* 比较段号S和段表长度M，若S>=M，则产生越界中断，否则继续执行
* 段号S对应的段表项地址=段表始址F+段号S*段表项长度，从该段表项中取出段长C，比较段内偏移量W与C的大小，判断是否出现越界（W>=c）
* 取出段表项中该段的始址b，计算E=b+W，用得到的物理地址E去访问内存

4. 分页V.S.分段

- 分页对用户不可见，分段对用户可见
- 页是信息的物理单位，段是信息的逻辑单位
- 分页由OS管理，对用户透明；分段需要在用户编程时实现
- 分页的地址空间是一维的，分段的地址空间是二维的
- 分段更容易实现信息的共享和保护(纯代码/可重入代码 可以共享)
- 分页(单级页表)、分段访问一个逻辑地址都需要两次访存，分段存储中也可引入快表机构

---

* 访问一个逻辑地址需要几次访存？

  分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存

  分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度


#### 3.1.5 段页式存储管理

* 分段 + 分页

​	将地址空间按照程序自身的逻辑关系划分为若干个段，再将各段分为大小相等的页面
将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存

* 段表、页表（一个进程有一个段表，每个段有一张页表）

​	每个段对应一个段表项。各段表项长度相同，由段号(隐含)、页表长度、页表始址
​	每个页对应一个页表项。各页表项长度相同，由页号(隐含)、页面存放的内存块号组成

* 分段、分页的优缺点

![1](https://i-blog.csdnimg.cn/blog_migrate/3023dede5f799f95cf0962b163b3c89c.png)

* 进程的逻辑地址：段号S|页号P|页内偏移量W
  * 段号的位数决定了每个进程最多可以分几个段
  * 页号位数决定了每个段最大有多少页
  * 页内偏移量决定了页面大小、内存块大小是多少

![1](https://i-blog.csdnimg.cn/blog_migrate/67218d3f024fcf8930e1bf6a67e06d45.png)

* 地址变换

![1](https://i-blog.csdnimg.cn/direct/f49698e1f4b749e7920a762a971520da.png)

### 3.2 虚拟内存管理

#### 3.2.1 虚拟内存的基本概念

1. 传统存储管理方式的特征

​	传统的操作系统的内存管理策略是为了同时将多个进程保存在内存中，具有以下性质

* 一次性：作业必须一次性装入内存后，才能开始运行；可能会导致的问题：
  * 作业很大就不能全部装入内存，就会无法运行
  * 当大量作业要求运行时，内存不足容纳所有作业，并发度下降
* 驻留性：作业装入内存后，就一直驻留在内存中，其任何部分都不会被换出直到作业运行结束

2. 局部性原理

​	快表、页高速缓存、虚拟内存技术都属于高速缓存技术

* 时间局部性：程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问后不久，可能再次被访问
* 空间局部性：一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内

3. 虚拟存储器的定义和特征

​	基于局部性原理，程序的一部分装入内存，一部分留在外存，==需要的时候将外存内容调入内存==，就好像产生了一个巨大的内存空间

特征：

* ==多次性==：作业在运行时，分多次调入内存运行，==最重要的特征==
* ==对换性==：作业不必一直驻留内存，允许作业在运行过程中进行换进换出
* ==虚拟性==：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量

4. 虚拟内存技术的实现

​	建立在离散分配的内存管理方式上

实现方式：

* 请求分页存储管理
* 请求分段存储管理
* 请求段页式存储管理

硬件支持：

* 一定容量的内存和外存
* 页表机制（或段表机制），作为主要的数据结构
* 中断机构，用户程序要访问的部分未调入内存时，则产生中断
* 地址变换机构，逻辑地址到物理地址的变换

#### 3.2.2 请求分页管理方式

​	系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了==请求调页==功能和==页面置换==功能

* 请求分页存储管理与基本分页存储管理的主要区别

​	在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。

​	若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

​	与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面==是否已经调入内存==；如果还没调入，那么也需要知道该页面在==外存中存放的位置==。

​	当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定==到底换出哪个页面==；有的页面==没有被修改过==，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面==是否被修改的信息==。

​	请求页表项增加了四个字段：是否已调；可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考入内存；页面调入内存后是否被修改过；页面在外存中的存放位置。

1. 页表机制

![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dkrk9uiw-1675238575007)(images/OS/image-20221017201949742.png)]](https://i-blog.csdnimg.cn/blog_migrate/694bce8c9d259ab8ea88a5478db7308f.png)



2. 缺页中断机构

​	当访问页面==不在内存时就会产生缺页中断==，请求操作系统的缺页中断处理程序处理。此时将缺页的进程阻塞放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

​	若内存中有空闲页框，则为进程分配一个页框，将所缺页面从外存装入该页框，并修改页表中相应表项，若内存中没有空闲页框，则由页面置换算法选择一个页面淘汰，若该页在内存期间被修改过，则还要将其写回外存（没修改就不用写回）

* 缺页中断和一般中断的区别
  * 在指令执行期间而非一条指令执行完成后产生和处理中断，属于内部异常
  * 一条指令执行期间可能产生多次缺页中断

3. 地址变换机构

   检索快表，找到访问页，修改页表项中的访问位，利用页表项中给出的物理块号和页内地址形成物理地址

   没有找到改页的页表项，去内存中寻找页表，看该页是否已经调入内存，没有调入则产生缺页中断，请求从外存把该页调入内存

![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D2xs61Ts-1675238575009)(images/OS/image-20221017203819494.png)]](https://i-blog.csdnimg.cn/blog_migrate/be5b51ccbc8084cd3f8734d89bff63c4.png)

#### 3.2.3 页框分配

1. 驻留集大小

​	对于分页式的虚拟内存，在进程准备执行时，不需要也不可能将一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。给一个进程分配的页框的集合就是这个进程的驻留集

* 驻留集越小，驻留在内存中的进程就越多，可以提高多道程序的并发度，但分配给每个进程的页框太少，会导致缺页率较高，cpu会耗费大量时间来处理页
* 驻留集越大，会浪费内存空间导致并发度的下降

2. 内存分配策略

​	在请求分页系统中，可以采取两种内存分配策略，即固定和可变分配策略；在进行置换时，也可以采用两种策略，即全局置换和局部置换

* 固定分配局部置换

​	为每个进程分配固定数目的物理块，在进程运行期间都不改变。所谓==局部置换==，是指若干进程在运行中发生缺页，则只能从分配给该进程在内存的页面中选出一页换出，然后调入内存保证分配给该进程的内存空间不变。

* 可变分配全局置换

​	先为每个进程分配一定的物理块，在进程运行期间可根据情况适当的增加或减少。所谓==全局置换==，是指进程在运行中发生缺页，则系统从空闲的物理块队列中取出一块分配给该进程，并将所缺页调入。（但是可能会导致多道程序的并发能力下降）

* 可变分配局部置换

​	为每个进程分配一定数目的物理块，当某进程发生缺页的时候，只允许从该进程在内存的页面中选出一页换出，因此不会影响其他进程的运行。若进程在运行中频繁的发生缺页中断，则系统再为该进程分配若干物理块，直至该进程的缺页率趋于适当程度；反之缺页率低就可以适当减少物理块

3. 物理块调入算法

* 平均分配算法--将系统中所有可供分配的物理块平均分配给各个进程
* 按比例分配算法--根据进程大小按比例分配
* 优先权分配算法--为重要和紧迫的进程分配较多的物理块

​	==通常采用的是一部分按比例分配、一部分根据优先权分配==

4. 调入页面的时机

* 预调页策略--根据局部性原理，一次调入若干个相邻的页面会比一次调入一页更高效，这种策略主要用于首次调入
* 请求调页策略--进程在运行过程中需要访问的页面不存在，便提出请求，由系统将其所需要页面调入内存。

* ==预调页是运行前的调入，请求调页是运行期间的调入==

5. 从何处调入页面

​	请求分页系统的外存分为两部分：用于==存放文件的文件区==和用于存放==对换页面的对换区==（交换区）。对换区采用连续分配方式，文件区采用离散分配方式，因此对换区的磁盘I/O速度比文件区更快

* 系统拥有足够的对换区空间：可以全部从对换区调入所需页面以提高调页速度。为此在进程运行前，需将与该进程有关的文件从文件区复制到对换区。
* 系统缺少足够的对换区空间：凡是不会被修改的文件都直接从文件区调入；当换出这些页面时，由于不会被修改而不必再换出。对于那些可能被修改的部分，换出时必须放在对换区，以后需要时再从对换区调入（因为读比写的速度快）
* UNIX方式。与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入，曾经运行过但又被换出的页面由于换出时放在对换区，因此下次调入是在对换区调入。进程请求的共享页面若被其他进程调入内存，则不需要再从对换区调入

6. 如何调入页面

​	当进程所访问的页面不在内存中的时候（访问位为0），便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块，此时若内存未满，则启动磁盘I/O，将所缺页调入内存，并修改页表。若内存已满，则先按某种置换算法从内存中选出一页准备换出；若该页未被修改过（修改位为0），则不用写回；但是若该页已被修改（修改位为1），则必须将该页写回磁盘，然后将所缺页调入内存，并修改相应的页表项，置存在位为1。

#### 3.2.4 页面置换算法

* 最佳（OPT）置换算法

选择永不使用或者==最长时间内==不再访问的页面进行淘汰，但是现实中是无法预知的

优点：缺页率最小，性能最好

* 先进先出页面置换算法（FIFO ）

优先淘汰==最早进入==的页面

优点：实现简单（将内存中页面按照调入的先后顺序排成一个队列）

缺点：与进程的实际运行规律不匹配

！Belady异常：增大分配的物理块数但是故障数不减反增―只有先进先出算法会出现

* 最近最久未使用（LRU ）置换算法

选择==最近最长时间==没有被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间（向前找最远的）

优点：性能好

缺点：实现==复杂==需要寄存器和栈的硬件支持LRU是堆栈类算法

* 时钟（CLOCK）置换算法

简单的CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页==被访问时，其访问位置为1==。当需要淘汰一个页面时，只需检查页的访问位。==如果是0，就选择该页换出==；==如果是1，则将它置为0==，暂不换出，继续检查下一个页面，若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面==最多会经过两轮扫描==）

优点：性能接近于最佳置换算法

缺点：实现复杂开销大

* 改进型CLOCK算法

使用位（访问位）的基础上增加修改位

扫描过程

扫描缓冲区，选择第一个使用位和修改位都为0的页面换出

第一步失败后，查找使用位为0，修改位为1的进行替换，对于每个跳过的帧，将使用位置为0

第二步失败后，指针回到初始地点且使用位（访问位）均为0，重复第一步

优点：相对于未改进型，节省了时间

#### 3.2.5 抖动和工作集

1. 抖动--页面要频繁换入换出内存
2. 工作集--在某段时间间隔内，进程要访问的页面集合。一般来说，工作集W可由时间t和工作集窗口尺寸来确定==驻留集不能小于工作集==

#### 3.2.6 内存映射文件

​	内存映射文件是操作系统向应用程序提供的一个==系统调用==，和虚拟内存相似，在磁盘文件与进程的虚拟地址空间之间建立映射关系

​	进程通过这个系统调用将一个文件映射到其虚拟地址空间的某个区域，之后就用访问内存的方式读写文件。这种功能将一个文件当作内存中的一个大字符数组来访问，而不通过文件I/O操作来访问。磁盘文件的读出/写入由操作系统完成，对进程而言是透明的。当映射进程的页面时，不会实际读入文件的内容，而只在访问页面时才被每次一页地读入，当进程退出或者关闭文件映射时，所有被改动地页面才被写回磁盘文件。

​	进程可以通过共享内存来通信，实际上，很多时候，==共享内存==是通过映射相同文件到通信进程的虚拟地址空间来实现的.但操作系统将对应的这些虚拟地址空间映射到相同的物理内存（用页表实现）

优点：

* 程序员编程更简单，建立映射的文件只需要按照内存访问的方式访问内存即可
* 方便多个进程共享同一个磁盘文件

#### 3.2.7 虚拟存储器性能影响因素

* 缺页率--页面大小、分配给进程的物理块数、页面置换算法、程序的编制方法
* 写回磁盘的频率--可以建立一个已修改换出页面的链表，达到一定值才统一写回

## 4 文件管理

### 4.0 考纲内容

* 文件
  * 文件的基本概念；文件元数据和索引节点（inode）
  * 文件的操作：建立，删除，打开，关闭，读，写
  * 文件的保护；文件的逻辑结构；文件的物理结构
* 目录
  * 目录的基本概念；树形目录；目录的操作；硬链接和软链接
* 文件系统
  * 文件系统的全局结构：文件系统在外存中的结构，文件系统在内存中的结构，外存空闲空间管理办法；虚拟文件系统；文件系统挂载

### 4.1 文件系统基础

#### 4.1.1 文件的基本概念

​	==文件==是以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。

1. 文件的定义

​	文件--创建者所定义的==一组相关信息==的集合

​	记录--一组数据项的集合，用于描述—个对象在某方面的==属性==

​	数据项：数据项是文件系统中==最低级的数据组织形式==

​	基本数据项：用于描述一个对象的==某种属性的一个值==

​	组合数据项：多个基本数据项组成

2. 文件的属性

​	文件名、标识符、类型、位置、大小、保护信息...文件内部应该如何被组织起来（文件的逻辑结构）

​	名称：文件名称唯一，以容易读取的形式保存

​	标识符：文件的==唯一标签==，通常为数字，是对人不可读的一种==内部名称==

​	类型：被支持的不同类型的文件系统所使用

​	位置：指向设备和设备上文件的==指针==

​	大小：文件当前的大小，包含文件允许的最大值

​	保护：对文件进行保护的访问控制信息

​	时间、日期和用户标识：文件创建、修改和上次访问的相关信息，用于保护和跟踪文件的使用

3. 文件的分类

* 按性质和用途：系统文件、用户文件、库文件
* 按文件中数据的形式分类：源文件、目标文件、可执行文件
* 按存取控制属性分类：可执行文件、只读文件、读/写文件
* 按组织形式和处理方式分类：普通文件、目录文件、特殊文件

#### 4.1.2 文件控制块和索引节点

1. 文件控制块（FCB）

​	==文件控制块==是用来存放控制文件需要的各种信息的数据结构，以实现==按名存取==。

​	文件与FCB一一对应，FCB的有序集合称为文件目录，一个FCB就是一个文件目录项

​	一个文件目录也被视为一个文件，称为目录文件。

​	每当创建一个新文件，系统就要为其建立一个FCB，用来记录文件的各种属性。

FCB主要包括：

* 基本信息：文件名、文件的物理位置、文件的逻辑结构、文件的物理结构
* 存取控制信息：文件主的存取权限、核准用户的存取权限以及哟版用户的存取权限
* 使用信息：如文件建立时间、上次修改时间

2. 索引节点

​	检索目录文件时，不需要将文件调入内存，只是==查找其目录项==，文件的描述信息单独形成为索引节点的数据结构

* 磁盘索引节点--存放在磁盘上的索引节点，每个文件有一个唯一的磁盘索引节点
  * 文件主标识符：拥有该文件的个人或小组的标识符
  * 文件类型：普通文件、目录文件、特别文件
  * 文件存取权限：各类用户对该文件的存取权限
  * 文件物理地址：每个索引节点中含有13个地址项，直接或者间接的方式给出数据文件所在盘块的编号文件长度：字节为单位
  * 文件链接计数：本文件系统中所有指向该文件的文件名的==指针计数==
  * 文件存取时间：文件最近被进程存取，修改以及索引节点最近被修改的时间
  * 文件长度：以字节为单位的文件长度
* 内存索引节点--存放在内存中的索引节点，文件被打开时，要将磁盘索引节点复制到内存的索引节点中
  * 索引结点编号：用于标识内存索引节点
  * 状态：指示i节点是否被上锁或者被修改
  * 访问计数：每当有一个进程要访问此i结点时，计数加1，访问结束减1
  * 逻辑设备号：文件所属文件系统的逻辑设备号
  * 链接指针：设置分别指向空闲雠表和散列队列的指针

#### 4.1.3 文件的操作

1. 基本操作

* 创建文件--为新文件分配外存空间；创建一个目录项
* 删除文件--根据文件名查找目录，删除指定文件对应的目录项何文件控制块，然后回收存储空间
* 读文件--根据文件命查找目录，找到指定文件的目录项后得到文件在外存中得地址；在目录项中，还有一个指针用于对文件进行读操作
* 写文件--为了写文件，根据文件名查找目录，找到指定文件得目录项后，再利用目录项中得写指针对文件进行写操作。（发生写操作，就要更新写指针）

2. 文件的打开和关闭

* 文件打开--先利用系统调用将文件打开，系统维护一个所有打开文件信息的表，称为打开文件表。（“打开”是指系统检索到指定文件的目录项之后，将该目录项从外存复制到内存中的打开文件表的一个表目中，并将该表目的索引号返回给用户）
* 文件关闭--整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。一个进程打开一个文件，系统打开文件表就会为打开的文件增加相应的条目。当另一个进程执行open时，只不过是在其进程打开表中增加一个条目，并指向整个系统表的相应条目。通常，系统打开文件表的每个文件时，还用一个文件打开计数器(Open Count)，以记录多少进程打开了该文件。每个关闭操作close则使count递减，当打开计数器为0时，表示该文件不再被使用。系统将回收分配给该文件的内存空间等资源，若文件被修改过，则将文件写回外存，并将系统打开文件表中相应条目删除，最后释放文件的文件控制块(File Control Block, FCB)。

​	==文件名不是打开文件表的一部分，一旦完成FCB在磁盘上的定位，文件操作都是通过文件描述符（索引号）来进行的==

​	打开文件的关联信息：

* 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。

* 文件打开计数：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。

* 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。

* 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的I/O请求。

#### 4.1.4 文件保护

1. 访问类型

* 读--从文件中读
* 写--向文件中写
* 执行--将文件装入内存并执行
* 添加--将新信息添加到文件结尾部分
* 删除--删除文件，释放空间
* 列表清单--列出文件名和文件属性

​	此外还可以对文件的重命名、复制、编辑等加以控制，这些高层的功能可以通过系统程序调用低层系统调用来实现

2. 访问控制

​	解决访问控制最常用的方法是根据用户身份进行控制，精简的访问控制列表可采用拥有者、组、其他三种用户类型

* 拥有者--创建文件的用户
* 组--一组需要共享文件且具有类似访问的用户
* 其他--系统内的所有其他用户

#### 4.1.5 文件的逻辑结构

文件的==逻辑结构==是从==用户观点出发==看到的文件的组织形式。

文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的存储组织形式。

文件的逻辑结构与存储介质特性无关，但文件的物理结构与存储介质的特性有很大关系。

按逻辑结构，文件有无结构文件和有结构文件两种类型：无结构文件和有结构文件。

1. 无结构文件

无结构文件是最简单的文件组织形式。它是由字符流构成的文件，所以又称流式文件

无结构文件将数据按顺序组织成记录并积累保存，它是有序相关信息项的集合，以字节(Byte)为单位。

对于流式文件的访问，是通过读写指针来指出下一个要访问的字节

由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，故这种文件形式对大多数应用不适用。

但字符流的无结构文件管理简单，用户可以方便地对其进行操作。

所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。

2. 有结构文件

​	是指一个以上的记录构成的文件，所以又称为记录式文件。各记录由相同或不同数目的数据项组成

根据各记录的长短是否相等，可以分为定长记录和变长记录

* 定长记录--所有记录的长度相同，各个数据项都在记录中相同的位置，具有相同的长度
* 变长记录--各记录的长度不一定相同，原因可能是记录中所含的数据项数目不同等

按照文件记录的组织形式可分为顺序文件、索引文件、索引顺序文件

* 顺序文件

  文件中的记录一个接一个地顺序排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，在访问时需要顺序搜索文件。顺序文件有以下两种结构：

  第一种是串结构，记录之间的顺序与关键字无关。通常的办法是由时间决定，即按存入时间的先后排列，最先存入的记录作为第1个记录，其次存入的为第2个记录，依此类推。

  第二种是顺序结构，指文件中的所有记录按关键字顺序排列。

  在对记录进行批量操作时，即每次要读或写一大批记录，对顺序文件的效率是所有逻辑文件中最高的；此外，也只有顺序文件才能存储在磁带上，并能有效地工作，但顺序文件对查找、修改、增加或删除单个记录的操作比较困难。

* 索引文件

  对于定长记录的顺序文件，要查找第i条记录，可直接根据下式计算得到第i条记录相对于第1条记录的地址：A~i~=i*L；然而，对于变长记录的顺序文件，要查找第i条记录，必须顺序的查找前i-1条记录，以获得相应记录的长度L，进而计算得出地址：![输入图片说明](https://images.gitee.com/uploads/images/2020/1006/105915_6313c4f5_508704.png)

  对于变长的顺序文件只能顺序查找，效率较低。为此，可以建立一张索引表，为主文件的每个记录在索引表中分别设置一个索引表项，其中包含指向记录的指针和记录长度，索引表按关键字排序，因此其本身也是一个定长记录的顺序文件

![输入图片说明](https://images.gitee.com/uploads/images/2020/1006/110007_7abf7d1f_508704.png)

* 索引顺序文件

​	索引顺序文件是顺序文件和索引文件的结合，最简单的索引顺序文件只使用了一级索引，先将变长记录顺序文件中的所有记录分为若干组，然后为文件建立一张索引表，并为每组中的第一个记录建立一个索引项，其中包含该记录的关键字和指向该记录的指针

​	主文件包括姓名和其他数据项，姓名为关键字，记录按姓名的首字母分组，同一个组内的关键字可以无序，但是组与组之间的必须有序。将每组的第一个记录的姓名机器逻辑地址放入索引表，索引表按照姓名递增。检索时先查找索引表，找到记录所在的组然后在组内使用顺序查找。

#### 4.1.6 文件的物理结构

​	==文件的物理结构==是指文件数据在物理存储设备上是如何分布和组织的

* 文件的分配方式--对非空闲块的管理
* 文件存储空间管理--对磁盘空闲块的管理

1. 连续分配--每个文件在磁盘上具有一组连续的块，磁盘地址定义了磁盘上的一个线性程序，这种排序使进程访问磁盘时需要的寻道数和寻道时间最小

​	采用连续分配，逻辑文件的记录也顺序存储在相邻的物理块。一个文件的目录项应该记录该文件的第一个磁盘块和所占用的块数。

优点：

* 支持顺序访问和直接访问
* 顺序访问速度快且容易，文件所占用的块可能位于一条或几条相邻的磁道上，磁头的移动距离最小

缺点：

* 要为一个文件分配连续的存储空间，和内存分配相似也会产生外部碎片
* 必须事先知道文件的长度，也无法满足文件动态增长的要求
* 保持文件的有序性。删除和插入记录需要对相邻记录做物理上的移动

2. 链接分配--是一种离散分配的方式

优点：

* 消除了磁盘的外部碎片，提高了利用率
* 便于动态地为文件分配块，无需事先知道文件的大小
* 文件的插入、修改、删除很方便

分类：

* 隐式链接--目录中含有文件第一块的指针和最后一块的指针，每个文件对应一个磁盘块的链表，磁盘块动态地分布在磁盘的任何地方。除文件最后一块外，每个盘块都有指向文件下一个盘块的指针，对用户透明

​	缺点：只支持顺序访问、且只要有一个指针出问题就会丢失数据文件，指针也会占空间

* 显示链接--文件分配表记录盘块号和指向下一块的指针

​	优点：支持顺序，直接访问、FAT常驻内存，检索速度快

​	缺点：FAT占内存

3. 索引分配

* 单级索引分配--将每个文件对应的盘块编号集中在一起，访问某个文件时就将文件对应的盘块号一起调入内存；==索引分配为每个文件分配一个索引块（表）==，将分配给该文件的所有盘块都记录在该索引块中

优点：

* 支持直接访问，当要访问第i块时，索引块的第i个条目指向的便是文件的第i个块
* 不会产生外部碎片

缺点：

* 索引块增加了额外的存储空间开销

主要问题：

* 每个文件必须有一个索引块，文件很小时，也要一个索引块，索引块的利用率很低
* 文件很大的时候，需要很多个索引块，方法低效

---

* 多级索引分配--文件太大，索引块很多，==就为索引块再建立一级索引==，称为主索引，记录每个索引块的盘块号

优点：

*  极大加快了对大型文件的查找速度

缺点：

* 当访问一个盘块时，要启动磁盘的次数随着索引级数的增加而增多，即使是对数量众多的小文件也是如此

---

* 混合索引分配方式--对于小文件直接将盘块地址放入FCB、中型文件采用单极索引、大型采用多级索引

### 4.2 目录

#### 4.2.1 目录的基本概念

​	FCB的有序集合就是文件目录，一个FCB就是一个文件目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权

#### 4.2.2 目录结构

1. 单级目录结构--整个文件系统只建立一张目录表，每个文件占一个目录项

​	建立一个新文件时，必须先检索所有目录项，以确保没有”重名“，然后在该目录中新增一项，将新文件的属性信息填入该项。	

​	单级目录实现了按名存取，但查找速度慢，不允许重名，不便于共享

2. 两级目录结构--分成主文件目录和用户文件目录

* 主文件目录--记录用户名及相应用户文件目录所在的存储位置
* 用户文件目录--记录该用户所有文件的FCB

3. 树形文件目录--推广的两级目录

​	当用户要访问某个文件，用文件的路径名标识文件，==文件路径名==是个字符串，由从根目录出发到所找文件通路上所有目录名与数据文件名用” / “链接而成。从根目录出发的路径称为绝对路径；从当前目录出发的路径称为相对路径！

4. 无环图目录结构

​	树形目录可以便于实现文件分类，但是文件共享不方便，为此在树形目录结构上增加一些指向同一节点的有向边，使得整个目录成为有向无环图，==允许目录共享子目录或者文件==，同一个文件或子目录可以出现在两个或多个目录中

​	可以为共享节点设置共享计数器，仅当共享计数器为0时才真正删除该节点

#### 4.2.5 文件共享

* 基于索引节点的共享方式--诸如文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针

![img](https://i-blog.csdnimg.cn/blog_migrate/b838bf44ce2db112dc1cadb8e4433c13.png)

* 利用符号链实现文件共享--类似于快捷方式

![文件共享软链接 的图像结果](data:image/jpeg;base64,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)

### 4.3 文件系统

#### 4.3.1 文件系统结构

文件系统设计的两个问题：

* 定义文件系统的用户接口
* 创建算法和数据结构，以便

文件系统层次结构：

* I/O控制层--包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息
* 基本文件系统--向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块
* 文件组织模块--组织文件及其逻辑块和物理块
* 逻辑文件系统--用于管理文件系统中的元数据信息（元数据包括文件系统所有的结构，而不包括实际数据或文件内容）

#### 4.3.2 文件系统布局

1. 文件系统在磁盘中的结构

* MBR（主引导记录）：位于磁盘的0号扇区，用来引导计算机，MBR的后面是分区表，该表给出每个分区的起始地址和结束地址。表中的第一个分区称为==活动分区==，计算机启动后，BIOS读入MBR，之后MBR确定活动分区读入他的第一块（引导块）
* 引导块：MBR执行引导块的程序后，该程序负责启动该分区中的操作系统。每个分区都是统一从一个引导块开始
* 超级块：包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存，其具有的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针
* 文件系统中空闲块的信息--可以用位示图或指针链接的形式给出

2. 文件系统在内存中的结构

* 内存中的安装表--包含每个已安装文件系统分区的有关信息
* 内存中的目录结构的缓存--包括最近访问目录的信息
* 整个系统的打开文件表--包含每个打开文件的FCB副本、打开计数及其他信息
* 每个进程的打开文件表--包含每个进程打开文件的文件描述符等

#### 4.3.3 外存空闲空间管理

1. 空闲表法

![img](https://i-blog.csdnimg.cn/blog_migrate/807d938c860abff5a2a53f32e0b32d8e.png)

​	盘块的分配：也采用首次适应、最佳适应等算法

​	盘块的回收：类似内存回收的策略

优点：具有较高的分配速度，可减少访问磁盘的I/O频率

2. 空闲链表法

* 空闲盘块链--是指磁盘上的所有空闲空间以盘块为单位成一条链。每个盘块都有指向下一个空闲盘块的指针（分配选头，回收加尾）

​	优点：分配回收简单

​	缺点：效率低、盘块链长

* 空闲盘区链--是指将所有空闲盘区成链，每个盘区包含若干相邻的盘块，每个盘区有指向下一个盘区的指针和本盘区的盘块数

​	优缺点和空闲盘块相反

3. 位示图法--外存上建立一张位示图，记录文件存储器的使用情况。每一位对应文件存储器上的一个物理块，取值0和1分别表示空闲和占用。

4. [成组链接法](https://www.bilibili.com/video/BV1HE41167kj/?spm_id_from=333.337.search-card.all.click&vd_source=885b32cef3776856ef5095348740fad3)--将空闲盘块分为若干组，如100个盘块作为一组，每组的第一个盘块记录下一组的空闲盘块总数和空闲盘块号。这样由每组的第一个盘块可以链接成一条链。==第一组的空闲盘块总数和空闲盘块号保存在内存的专用栈（空闲盘块号栈）==

![img](https://i-blog.csdnimg.cn/blog_migrate/caa4436574f2711a271f441d499ac503.png)

## 5 I/O管理

### 5.0 考纲内容

* I/O管理基础
  * 设备：设备的基本概念、设备的分类、I/O接口
  * I/O控制方式：轮询、中断、DMA
  * I/O软件层次结构：中断处理程序、驱动程序、设备独立性软件、用户层I/O软件
  * 输入、输出应用程序接口：字符设备接口、块设备接口、网络设备接口、阻塞/非阻塞I/O
* 设备独立性软件
  * 缓冲区管理；设备分配与回收、假脱机技术、设备驱动程序接口
* 外存管理
  * 磁盘：磁盘结构、格式化、分区、磁盘调度算法
  * 固态硬盘：读写性能特效，磨损均衡

### 5.1 I/O管理概述

#### 5.1.1 I/O设备

1. 设备的分类

* 按照信息交换地单位分类

  * 块设备：信息的交换以数据块为单位，如磁盘、磁带等。磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读/写任意一块

  * 字符设备：信息交换以字符为单位，如交互式终端机、打印机等。他们的基本特征是传输速率较低、不可寻址，并且时常采用中断I/O方式

* 按设备的传输速率分类

  * 低速设备--键鼠
  * 中速设备--激光打印机
  * 高速设备--磁盘机、光盘机

* 按设备地使用特性分类

  * 独占设备：同一时刻只能由一个进程占用地设备--打印机（一般的低速设备都是）
  * 共享设备：同一时间段允许多个进程同时访问的设备，通过分时的方式使用--磁盘
  * 虚拟设备：通过SPOOLing技术将独占设备改造为共享设备，将一个物理设备变为多个逻辑设备，从而将设备同时分配给多个进程

2. I/O接口

​	I/O接口（设备控制器）是cpu与设备之间的接口，以实现设备和计算机之间的数据交换。它接收发自CPU的命令，控制设备工作，使得CPU能从繁忙的设备控制事务中解脱出来。

![I/O接口 的图像结果](https://i-blog.csdnimg.cn/direct/ef78166cf28540ae903dad38849721f5.png)

* 设备控制器和CPU的接口：用于实现CPU与设备控制器之间的通信，该接口有三类信号线：数据线、地址线、控制线。数据线传送读写数据、控制信息和状态信息；地址线传送的是要访问的I/O接口中的寄存器编号；控制线传送的是读/写控制信号。
* 设备控制器和设备的接口：一个设备控制器可以链接一个或者多个设备，因此控制器中有一个或多个设备接口。每个数据都可以传输数据、控制和状态信号。
* I/O逻辑：用于实现对设备的控制，它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。CPU启动设备时，将启动命令发送给控制器，同时通过地址线将地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并对所选设备进行控制。

​	设备控制器的主要功能有：接收和识别命令；数据交换；标识和报告设备的状态；地址识别；数据缓冲；差错控制

3. I/O接口的类型

* 按数据传送方式（外设和接口一侧）：可以分为==并行接口==（一个字节或者一个字的所有位同时传送）和==串行接口==（一位一位的有序传送），接口要完成数据格式的转换
* 按主机访问I/O设备的控制方式：可分为程序查询接口、中断接口、DMA接口
* 按功能选择的灵活性：可分为可编程（接口的功能可以通过编程改变）接口、不可编程接口

4. I/O端口

​	I/O端口是指设备控制器中可被CPU直接访问的寄存器

* 数据寄存器：用于缓存从设备送来的输入数据或从CPU送来的输出数据
* 状态寄存器：保存设备的执行结果或状态信息，以供CPU读取
* 控制寄存器：由CPU写入，以便启动命令或更改设备模式

​	I/O设备要想能够被CPU访问，就要对各个端口进行编址，每个端口对应一个端口地址。而对I/O端口的编制方式有与存储器独立编址和统一编址两种

* 独立编址：为每个端口分配一个I/O端口号，I/O端口的地址空间和主存地址空间是两个独立的地址空间，范围可以重叠，相同地址可能属于不同的地址空间。普通用户程序不能对端口进行访问，只有OS使用特殊的I/O指令才能访问端口

优点：I/O端口数比主存单元少，只需要少量的地址线，使得I/O端口译码简单，寻址速度更快。使用专用I/O指令可使程序更加清晰

缺点：I/O指令少，只提供简单的传输操作，程序设计的灵活性差，此外cpu需要提供两组独立的存储器和设备的读写控制信号，增加了控制的复杂性

* 统一编址：又称为内存映射I/O，是指将主存地址空间分出一部分给I/O端口进行编址，I/O端口和主存单元在同一地址空间的不同分段中，根据地址范围就能区分访问的是I/O端口还是主存单元，可以用==统一的访存指令就可以访问I/O端口

优点：不需要专门的I/O指令，端口可用的编制空间大

缺点：主存可用容量变小，译码电路变复杂，降低了寻址速度

#### 5.1.2 I/O控制方式

​	I/O是指控制设备和主机之间的数据传送

1. 程序直接控制方式:CPU对程序的控制采取轮询的I/O方式。

* 传送单位：字

- 主要缺点和主要优点

优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）。

缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。

【注意】它不会进入阻塞态。

<img src="https://i-blog.csdnimg.cn/direct/9d4b2d2b9e224d458f16bc40e802466a.png" alt="1" style="zoom: 33%;" />

<img src="https://i-blog.csdnimg.cn/direct/92e6afbd510c40a4a3fb44119f8418ad.png" alt="在这里插入图片描述" style="zoom: 25%;" />

2. 中断驱动方式：允许I/O设备主动打断CPU的运行并请求服务，从而“解放”CPU，使得CPU向设备控制器

* 传送单位：字

* 流程
  * 发出一条I/O指令后可以继续做其他有用的工作
  * 由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。
  * 当I/O完成后，控制器会向CPU发出中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。
  * 处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。
    接着，CPU恢复等待l/O的进程（或其他进程）的运行环境，然后继续执行。

* 【注意】：
  * CPU会在每个指令周期的末尾检查中断；
  * 中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。
* 主要缺点和主要优点
  * 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。CPU和I/O设备可并行工作，CPU利用率得到明显提升。
  * 缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。

<img src="https://i-blog.csdnimg.cn/direct/30fb458035394fc3b821e0f30212351a.png" alt="在这里插入图片描述" style="zoom: 33%;" />

![image-20241105224412626](D:/learn/408_review/img/img3.png)

3. DMA方式：在i/o设备与内存之间开辟直接的==数据交换通路==，彻底解放CPU

特点如下：

1. 数据的**传送单位**是“**块**”。不再是一个字、一个字的传送；
2. 数据的流向是从设备直接放入内存，或者从内存直接到设备。
3. 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。

<img src="https://i-blog.csdnimg.cn/direct/24529cbdea4d4e8383e08575804ac72d.png" alt="在这里插入图片描述" style="zoom:25%;" />

![img](https://pic3.zhimg.com/v2-7cea49e11592049c4f943192ef67f226_1440w.jpg)

DMA控制器必须具有以下四类寄存器：

* 命令／状态寄存器(CR) 。用于接收从CPU 发来的I/0 命令或有关控制信息，或设备的状态。
* 内存地址寄存器(MAR) 。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。
* 数据寄存器(DR) 。用于暂存从设备到内存或从内存到设备的数据。
* 数据计数器(DC) 。存放本次要传送的字（节）数。

​	DMA方式的工作过程是： CPU 接收到I/O 设备的DMA 请求时，它给I/0 控制器发出一条命令，启动DMA 控制器，然后继续其他工作。之后CPU 就把控制操作委托给DMA 控制器，由该控制器负责处理。DMA 控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU 参与。传送完成后，DMA 控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与

#### 5.1.3 I/O软件层次结构

<img src="https://i-blog.csdnimg.cn/direct/644e63169d64448b8a6ca83e926c30cb.png" alt="在这里插入图片描述" style="zoom:25%;" />

* 用户层软件：
  * 向上，实现了与==用户交互==的接口，用户可直接使用该层提供的、与l/O操作相关的库函数对设备进行操作。
  * 向下，将用户请求翻译成格式化的I/O请求，并通过“==系统调用==”请求操作系统内核的服务。

* 设备独立性软件：又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。I/O系统的最高层软件（在往上就是用户）。应用程序使用逻辑设备名来请求设备，系统负责转换成物理设备名

  * 什么是设备独立性？
    设备独立性：是指操作系统把所有外部设备统一当作成特殊文件来看待，只要安装它们的驱动程序，任何用户都可以象使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。

  * 为什么要引入设备独立性？（优点）
    * 可以方便用户操作，易于实现IO重定向；
    * 使程序运行不受具体机器的影响；
    * 调高设备的利用率和分配时的灵活性；
    * 提高系统的可适应性和可扩展性；
    * 设备独立性软件主要实现的功能（如何实现设备独立性）：
    * 向上层提供统一的调用接口（如read/write系统调用）。

  * 提供：控制寄存器、状态寄存器、控制命令

  * 设备的保护:原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。

  * 差错处理：设备独立性软件需要对一些设备的错误进行处理。

  * 设备的分配与回收。

  * 数据缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。

  * 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序。用户或用户层软件发出l/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名。

​		设备独立性软件需要通过“逻辑设备表（LUT）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。

* 设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。
* 中断处理程序：用于保存被中断进程的现场，转入相应的中断处理程序进行处理，处理完成后再恢复现场

#### 5.1.4 应用程序I/O接口

1. I/O接口分类

* 字符设备接口
  get/put系统调用：向字符设备读/写一个字符。

* 块设备接口
  read/write系统调用：向块设备的读写指针位置读/写多个字符；

  seek系统调用：修改读写指针位置。

* 网络设备接口，又称"网络套接字(socket)接口”。

  socket系统调用：创建一个网络套接字，需指明网络协议（TCP? UDP? ）。

  bind：将套接字绑定到某个本地“端口”。

  connect：将套接字连接到远程地址。

  read/write：从套接字读/写数据。

2. 阻塞/非阻塞I/O

* 阻塞I/O：应用程序发出**I/O系统调用**，进程需转为**阻塞态**等待。
* 非阻塞I/O：应用程序发出I/O系统调用，系统调用可**迅速返回**，进程**无需阻塞等待**。

### 5.2 设备独立性软件

#### 5.2.1 设备独立性软件

​	也称与设备无关的软件，是I/O系统最高层软件，他的下层是设备驱动程序

#### 5.2.2 高速缓存和缓冲区

1. 磁盘高速缓存--用来提高磁盘的I/O速度，对访问高速缓存要比访问原始磁盘数据更快

​	逻辑上属于磁盘，物理上是驻留内存的盘块

* 存在形式：内存中的单独空间；将未利用的内存空间作为一个缓冲池

2. 缓冲区

引入目的：

* 缓和CPU和I/O设备速度不匹配的矛盾
* 减少对CPU的中断频率，放宽对CPU中断响应时间的限制
* 解决基本数据单元大小（数据粒度）不匹配的问题
* 提高CPU和I/O设备的并行性

缓冲技术的分类：单缓冲MAX（C,T）+M、双缓冲MAX（C+M,T）、循环缓冲、缓冲池

#### 5.2.3 设备的分配和回收

1. 概述：根据用户的I/O请求分配所需要的设备
2. 设备分配的数据结构：

* 设备控制表(DCT)，表中的表项就是设备的各个属性
  * 设备类型、设备标识符、设备状态、指向控制器表的指针、重复执行次数或时间、设备队列的队首指针
* 控制器控制表(COCT)：操作系统根据COCT的信息对控制器进行操作和管理

<img src="https://i-blog.csdnimg.cn/blog_migrate/92e7c4e8b6ed8271443eb3198f703e60.png#pic_center" alt="在这里插入图片描述" style="zoom: 50%;" />

* 通道控制表(CHCT)：操作系统根据CHCT的信息对通道进行操作和管理。

<img src="https://i-blog.csdnimg.cn/blog_migrate/24faca3cb0143e77acbf7e77401fb85b.png#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

* 系统设备表(SDT)：记录了系统中全部设备的情况，每个设备对应一个表目。

<img src="https://i-blog.csdnimg.cn/blog_migrate/dceffd6e5ef81b6e3497a3f67d22919a.png" alt="在这里插入图片描述" style="zoom:50%;" />

3. 设备分配要考虑的因素

* 设备的固有属性
  设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。
  独占设备——一个时段只能分配给一个进程（如打印机）
  共享设备——可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。
  虚拟设备——采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）
  设备的分配算法：先来先服务、优先级高者优先、短任务优先…
* 从进程运行的安全性上考虑，设备分配有两种方式：
  ①、安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。（eg：考虑进程请求打印机打印输出的例子）
  【一个时段内每个进程只能使用一个设备
  优点：破坏了“请求和保持”条件，不会死锁
  缺点：对于一个进程来说，CPU和I/O设备只能串行工作】
  ②、不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。
  【一个进程可以同时使用多个设备
  优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进
  缺点：有可能发生死锁（死锁避免、死锁的检测和解除）】

* 通常采用的算法：FCFS、最高优先级优先算法

4. 设备分配步骤

①、根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）
②、查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。
③、根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
④、根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

<img src="https://i-blog.csdnimg.cn/blog_migrate/e0150d62194d10649edbf43d7cbd2636.png#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

5. 逻辑设备到物理设备名的映射：配置逻辑设备表（LUT），包含逻辑设备名、物理设备名、驱动程序入口地址

​	设置表的方式：整个系统一张、每个用户一张

#### 5.2.4 SPLOOing技术

<img src="https://i-blog.csdnimg.cn/blog_migrate/6f6c5b22c9c89af155f87c923302a575.png" alt="在这里插入图片描述" style="zoom:75%;" />

流程：

​	①在外围控制器的控制下，慢速输入设备的数据先被输入到更快速的磁带上，之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾
​	②引入脱机技术之后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备纸带机正在忙碌，也可以提前将数据输出到磁带

​	输入井/输出井模拟磁带机、输入进程/输出进程模拟外围控制机、输入缓冲区/输出缓冲区相当于数据中转站

* 脱机管理进程为每个进程做两件事：
  ①在磁盘输出井中，为进程申请一个空闲缓冲区，并将要打印的数据送入其中。
  ②为用户进程申请一张空白的打印请求表（包含用户的打印数据存放位置等信息），并将用户的打印请求填入表中，再将该表挂到假脱机文件队列上。

* SPOOLing技术的特点：

​	提高了I/O速度。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。
​	将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设备，而只是在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表。这样，便把独占设备改造为共享设备。
实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。

### 5.3 磁盘和固态硬盘

#### 5.3.1 磁盘

<img src="https://i-blog.csdnimg.cn/blog_migrate/c1fcbbd54a00a12a821ee2714ede3e71.png" alt="img" style="zoom:50%;" />

#### 5.3.2 磁盘的管理

1. 磁盘初始化

​	一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为低级格式化(或称物理格式化)。

2. 分区 

​	在可以使用磁盘存储文件之前，操作系统还要将自己的数据结构记录到磁盘上，分为两步:第一步是，将磁盘分为由一个或多个柱面组成的分区(即我们熟悉的C盘、D 等形式的分区)每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中;第二步是，对物理分区进行逻辑格式化(创建文件系统)，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录。

​	因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一簇。

3. 引导块

​	计算机启动时需要运行一个初始化程序(自举程序)，它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存，并转到起始地址，从而开始操作系统的运行。

​	自举程序通常存放在 ROM 中，为了避免改变自举代码而需要改变 ROM 硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。

​	 Windows允许将磁盘分为多个分区，有一个分区为引导分区，它包含操作系统和设备驱动程序。 Windows系统将引导代码存储在磁盘的第0号扇区，它称为主引导记录(MBR)。引导首先运行 ROM中的代码，这个代码指示系统从MBR中读取引导代码。除了包含引导代码，MBR还包含 一个磁盘分区表和一个标志(以指示从哪个分区引导系统),如图5.17所示。当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。

<img src="https://i-blog.csdnimg.cn/blog_migrate/49da3c76c7baceb7870066473615daf2.png" alt="联想截图_20240731230711.png" style="zoom:33%;" />

4. 坏块

​	由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。部分磁盘甚至在出厂时就有坏块。

​	对于简单磁盘，如采用IDE 控制器的磁盘，坏块可手动处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT 表上会标明，因此程序不会使用它们。

​	对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。

​	对坏块的处理实质上就是用某种机制使系统不去使用坏块。

#### 5.3.3 磁盘调度算法

1. 磁盘的存取时间

* 寻找时间 T：活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。这个时间除跨越n条磁道的时间外，还包括启动磁臂的时间s，即 T= m x n + s ,式中，m是与磁盘驱动器速度有关的常数，约为0.2ms，磁臂的启动时间约为2ms。

* 旋转延迟时间T2。磁头定位到某一磁道的扇区所需要的时间，设磁盘的旋转速度为r，则

  T2=1 / 2r 

* 传输时间 T3。从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数 b和磁盘的旋转速度:
  T3 = b / rN
  式中，r为磁盘每秒的转数，N为一个磁道上的字节数。
  在磁盘存取时间的计算中，寻道时间与磁盘调度算法相关;而延迟时间和传输时间都与磁盘旋转速度相关，且为线性相关，所以在硬件上，转速是磁盘性能的一个非常重要的参数。


  总平均存取时间T4可以表示为  T4 = T1 + 1 / 2r + b / rN

2. 磁盘调度算法

* 先来先服务 ( First Come First Served，FCFS) 算法
  FCFS 算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法。

* 最短寻找时间优先(Shortest SeekTime First,SSTF) 算法

  SSTF 算法选择调度处理的磁道是与当前磁头所在碰道距离最近的磁道，以便使每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但能提供比 FCFS 算法更好的性能。这种算法会产生“饥饿”现象。

* 扫描 (SCAN)算法(又称电梯调度算法)

  SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象，实际上就是在最短寻找时间优先算法的基础上规定了碰头运动的方向，由于磁头移动规律与电梯运行相似，因此又称电梯调度算法。SCAN 算法对最近扫描过的区域不公平，因此它在访问局部性方面不如FCFS 算法和SSTF 算法好。

* 循环扫描 (Circular SCAN,C-SCAN)算法

  在扫描算法的基础上规定磁头单项移动来提供服务，回返时直接快速移动起始端而不服务任何请求。

  采用SCAN 算法和 C-SCAN 算法时，磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点这种形式的SCAN算法和C-SCAN 算法称为LOOK调度

![img](https://i-blog.csdnimg.cn/blog_migrate/f340a6355374f58aacd3186bdf82ea6e.png)

3. 减少延迟时间的办法

​	除减少寻道时间外，减少延迟时间也是提高磁盘传输效率的重要因素。
​	磁盘是连续自转设备，磁头读入一个扇区后，需要经过短暂的处理时间，才能开始读入下一 个扇区。若逻辑上相邻的块在物理上也相邻，则读入几个连续的逻辑块可能需要很长的延迟时间。 为此，可对一个盘面的扇区进行交替编号,即让逻辑上相邻的块物理上保持一定的间隔，于是读入多个连续块时能够减少延迟时间。

​	此外，由于磁盘的所有盘面是同步转动的，逻辑块在相同柱面上也是按盘面号连续存放的， 即按0号盘0号扇区、0号盘1号扇区……0号盘7号扇区、1号盘0号扇区……1号盘7号扇区、 2号盘0号扇区……的顺序存放。要读入不同盘面上的连续块，在读完0号盘7号扇区后，还需 要一段处理时间，所以当磁头首次划过1号盘0号扇区(下一次要读的块)时，并不能读取，只 能等磁头再次划过该扇区时才能读取。为此，可对不同的盘面进行错位命名[假设有2个盘面， 且已采用交替编号],则读入相邻两个盘面的连续块时也能减少延迟时间。

​	在磁盘的存取时间中，寻道时间和延迟时间属于“找”的时间，凡是“找”的时间都可以通 过一定的方法优化，但传输时间是磁盘本身性质所决定的，不能通过一定的措施减少。

4. 提高磁盘 I/O 速度的方法
   文件的访问速度是衡量文件系统性能最重要的因素，可从以下三个方面来优化：
   ①改进文件 的目录结构及检索目录的方法，以减少对目录的查找时间；
   ②选取好的文件存储结构，以提高对 文件的访问速度；
   ③提高磁盘I/O速度，以实现文件中的数据在磁盘和内存之间快速传送。

​	其中， ①和②已在第4章文件管理中介绍，这里主要介绍如何提高磁盘I/O的速度。

* 改善磁盘I/O性能的方法
  1)采用磁盘高速缓存。
  2)调整磁盘请求顺序。即上面介绍的各种磁盘调度算法。
  3)提前读。在读磁盘当前块时，将下一磁盘块也读入内存缓冲区。
  4)延迟写。仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链 表的尾部，当其他进程申请到此缓冲区时，才真正将缓冲区信息写入磁盘块。
  5)优化物理块的分布。除了上面介绍的扇区编号优化，当文件采用链接方式和索引方式组 织时，应尽量将同一个文件的盘块安排在一个磁道上或相邻的磁道上，以减少寻道时间。 另外，将若干盘块组成簇，按簇对文件进行分配，也可减少磁头的平均移动距离。
  6)虚拟盘。是指用内存空间去仿真磁盘，又叫RAM盘。常用于存放临时文件。
  7)采用磁盘阵列RAID。由于可采用并行交叉存取，因此能大幅提高磁盘I/O速度。（RAID 属于计算机组成原理存储介质部分内容）

#### 5.3.4 固态硬盘

![联想截图_20240731234021.png](https://i-blog.csdnimg.cn/blog_migrate/9fe3cf1e7a7fc09c1b9aea40c06f1241.png)





