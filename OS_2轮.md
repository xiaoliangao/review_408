# **操作系统二轮**

## 1 操作系统概述

### 1.0 考纲内容

* 操作系统的基本概念
* 操作系统的发展历程
* 程序运行环境、cpu运行模式：内核与用户、中断和异常的处理、系统调用、程序的链接装入、程序运行时的内存映像与地址空间
* 操作系统结构-分层、模块化、宏内核、微内核、内核
* 操作系统引导
* 虚拟机

#### 1.1 操作系的基本概念

#### 1.1.1 操作系统的概念

操作系统（Operating System， OS）是指==控制==和==管理==整个计算机系统的==硬件和软件==资源，并合理地组织调度计算机的工作和资源的分配；以==提供给用户和其他软件方便的接口和环境==；它是计算机系统中最基本的==系统软件==。

#### 1.1.2 操作系统的特征

并发、共享、异步、虚拟

* 并发：两个或者多个事件在==同一时间间隔==内发生使得系统具有处理和调度多个程序同时执行的能力操作系统的并发是通过分时实现的（时间片、流水线技术）
* 共享：互斥共享--打印机、同时访问--磁盘
* 虚拟：时分复用、空分复用
* 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，多道程序走走停停，进程以不可预知的速度向前进

![image-20210805094410098](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805094410098.png)

#### 1.1.3 操作系统的功能和目标

1. 操作系统作为系统资源的管理者
2. 操作系统作为用户与计算机硬件系统之间的接口（向上层提供方便易用的服务）
   * ==封装==思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。
3. 操作系统实现了对计算机资源的扩充（最接近硬件的一层软件）
   * 需要实现对==硬件机器的拓展== 没有任何软件支持的计算机称为==裸机==。在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器 通常把覆盖了软件的机器成为==扩充机器==，又称之为==虚拟机==

![image-20210805101358216](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805101358216.png)

### 1.2 操作系统的发展历程

#### 1.2.1 手工操作阶段

该阶段没有操作系统都是人工干预

缺点：

* 用户独占全机，资源利用率低
* cpu等待用户操作，利用不充分

![image-20210805103313437](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805103313437.png)

#### 1.2.2 批处理阶段

为了解决人机之间速率不匹配的矛盾，出现了批处理系统

* 单道批处理系统
  * 为实现对作业的连续处理，需要先将一批作业以脱机方式输入磁带，并且在系统中配上监督程序。内存中始终保持一道作业。

主要特征如下：

* 自动性--无需人工干预，自动逐个执行
* 顺序性--先调入的先执行
* 单道性--内存中仅有一道程序执行

![image-20210805103327096](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805103327096.png)

* 多道批处理系统
  * 用户所提交的作业存放在外村上并排成一个队列，作业调度程序按一定的算法从后备队列中选择若干作业调入内存，在管理程序的控制下相互穿插的运行，共享系统中的各种硬/软件资源。某道程序因请求I/O操作而站厅的时候，cpu就去运行另一道程序，这是通过中断机制实现的。
* 多道程序设计的特点是：微观上串行、宏观上并行
  * 多道--内存中有多道程序
  * 宏观上并行--同时进入系统的多道程序都处于运行过程中，但都未运行完毕
  * 微观上串行--内存中多道程序轮流占有cpu，交替执行
* 多道程序需要解决的问题：
  * 如何分配处理器
  * 多道程序的内存分配问题
  * I/O设备如何分配
  * 如何组织和存放大量的程序和数据，以保证安全性和一致性

优点：

* 资源利用率高
* 系统吞吐量大

缺点：

* 无人机交互能力
* 用户响应时间长

![image-20210805103337476](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805103337476.png)

#### 1.2.3 分时操作系统

计算机以==时间片==为单位==轮流==为各个用户/作业服务，各个用户可通过终端与计算机进行交互。 主要优点：用户请求可以被即时响应，==解决了人机交互问题==。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 主要缺点：==不能优先处理一些紧急任务==。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。

主要特征：

* 同时性：多个终端用户同时使用一台计算机
* 交互性：可以人机交互（参考Linux的terminal）
* 独立性：多个用户彼此独立地进行操作，互不干扰。使用户感觉独占计算机
* 及时性：很短时间内就能响应用户

#### 1.2.4 实时操作系统

![image-20210805104005902](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805104005902.png)

主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且==要在严格的时限内处理完事件==。实时操作系统的主要特点是==及时性和可靠性==

#### 1.2.5 网络操作系统和分布式计算机系统

* 网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）
* 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

![image-20210805104401758](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210805104401758.png)

### 1.3 操作系统的运行环境

#### 1.3.1 处理器运行模式

cpu通常执行两种不同性质的程序：

* 操作系统内核程序
* 用户自编程序（系统外层的应用程序，简称应用程序）

​	前者是后者的管理者，因此“管理程序”（内核程序）要执行一些特权指令，但是“app”不能执行特权指令

-----

“指令”就是处理器（CPU）能识别、执行的最基本命令，指==二进制==机器指令

* 特权指令：是指不允许用户直接使用的指令，如I/O指令、关中断指令、内存清零指令、存取用于内存保护的寄存器、送PSW到程序状态字寄存器
* 非特权指令：指用户可以直接使用的指令，它不可以直接访问系统中的软硬件资源，仅限于访问用户的地址空间

**cpu运行模式**--用户态（目态）、核心态（管态、内核态）

处于内核态时，说明此时正在运行的是==内核程序==，此时可以执行==特权指令== 处于用户态时，说明此时正在运行的是==应用程序==，此时只能执行==非特权指令==

内核态--用户态：执行一条==特权指令==——修改==PSW==的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 用户态--内核态：由“==中断==”引发，==硬件自动完成变态过程==，触发中断信号意味着操作系统将强行==夺回==CPU的使用权

1. 时钟管理--通过时钟管理完成进程切换（时间片轮转调度）

2. 中断机制--I/O、进程调度、系统功能的调用、设备驱动、文件访问都离不开中断机制（只有一部分属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序）

3. ==原语==--按层次结构设计的操作系统，底层是一些可以被调用的小程序，各自完成一个规定的操作，这些程序称为原语

   * 操作系统的底层，最接近硬件的部分
   * 这些程序的运行具有原子性，操作只能一气呵成
   * 运行时间短，调用频繁

   定义原语的直接方法是：关中断、完成所有动作不可分割地完成后再打开中断。（系统中地设备驱动、cpu切换、进程通信等功能中地部分操作都可以定义为原语，使他们内核地组成部分）

4. 系统控制的数据结构及处理

   如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表

   基本操作:

   * 进程管理
   * 存储器管理
   * 设备管理

核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令

#### 1.3.2 中断和异常的概念

在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑两种状态之间如何切换。

==操作系统内核工作在核心态==，而==用户程序工作在用户态==。

---

“中断”是让操作系统内核==夺回CPU使用权==的唯一途径

1. 中断和异常的定义

==中断（外中断）==，是指来自cpu执行==指令外部==的事件，通常用于信息输入/输出，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务。

==异常（内中断）==，是指来自cpu执行==指令内部==的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。异常不能被屏蔽，一旦出现，就应立即处理。

![image-20210806093050375](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806093050375.png)

2. 中断和异常的分类

​	外中断可分为可屏蔽中断和不可屏蔽中断。

* 可屏蔽中断是指INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断
* 不可屏蔽中断是指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电

​	异常可以分为故障、自陷和终止

* 故障：由指令执行引起的异常，非法操作码、缺页故障、除数为0、运算溢出
* 自陷：是一种事先安排的“异常“事件，用于用户态下调用操作系统内核程序，如trap指令
* 终止：使得cpu无法继续执行的硬件故障，如控制器出错、存储器校验错

3. 中断和异常的处理过程

​	当cpu在执行用户程序的第i条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号，则cpu打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，cpu执行中断或者异常返回指令，回到第i条或第i+1条指令继续执行；若中断或者异常处理程序发现是不可恢复的致命错误，则终止应用程序。

#### 1.3.3 系统调用

“系统调用”是操作系统==提供给应用程序==（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求==获得操作系统内核==的服务

系统调用的功能：涉及系统资源管理、进程管理

* 设备管理--完成设备的请求/释放/启动
* 文件管理--完成文件的读/写/创建/删除
* 进程控制--完成进程的创建/撤销/阻塞/唤醒
* 进程通信--完成进程之间的消息传递/信号传递
* 内存管理--完成内存的分配/回收

​	系统调用的处理过程：

* 将系统调用号和所需要的参数压入堆栈；调用实际的调用指令，然后执行陷入指令将cpu状态从用户态转为核心态，再后由==硬件和操作系统内核程序保护被中断进程的现场==，具体是将PC、PSW以及通用寄存器内容等压入堆栈
* 分析系统调用类型，转入相应的系统调用处理子程序（根据系统调用入口表）
* 在系统调用处理子程序执行结束后，恢复被中断的或者设置新进程的cpu现场，然后返回被中断进程或新进程

![1](https://tse4.mm.bing.net/th/id/OIP.qLmnWO04mS73cFTYNI2stAHaCv?rs=1&pid=ImgDetMain)

---

用户态转为核心态

* 用户程序要求操作系统的服务--系统调用
* 发生一次中断
* 用户程序产生了一个错误状态
* 用户程序中企图执行一条特权指令

核心态转为用户态

* 一条特权指令，一般是中断返回指令

### 1.4 操作系统结构

1. 分层法

​	将操作系统分为若干层，底层（层0）为硬件层，顶层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单项依赖）

优点：

* 便于系统的调试和验证，简化了系统的设计和实现
* 易于扩充和易维护

问题：

* 合理定义各层比较困难
* 效率较差

2. 模块化

将操作系统按照功能划分为若干具有一定的独立性的模块，每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好子模块之间的接口

优点：

* 提高了操作系统设计的正确性、可理解性和可维护性
* 增强了操作系统的可适应性
* 加速了操作系统的开发过程

缺点：

* 模块间的接口规定很难满足对接口的实际需求

3. 宏内核（单内核、大内核）--Linux、unix

​	将OS的主要功能模块都作为系统内核，运行在核心态，通常也采用了“模块化”的思想

- 优点：性能高，内核内部各种功能都可以直接相互调用
- 缺点：
  - 内核庞大功能复杂，难以维护
  - 大内核中某个功能模块出错，就可能导致整个系统崩溃

4. 微内核--Windous NT

​	只把中断、原语、进程通信等最核心的功能放入内核，进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态

​	微内核将操作系统划分为两大部分：微内核和多个服务器

​	微内核包括：与硬件紧密相关的、一些基本功能、客户与服务器之间的通信

* 微内核基本功能：

  * 进程/线程管理

  * 低级存储器管理

  * 中断和陷入处理

* 特点

  * 扩展性和灵活性
  * 可靠性和安全性
  * 可移植性
  * 分布式计算

---

* 优点：

  - 内核小功能少、易于维护，内核可靠性高

  - 内核外的某个功能模块出错不会导致整个系统崩溃

- 缺点：
  - 性能低，需要频繁地在核心态/用户态之间切换
  - 用户态下的各功能模块不可直接相互调用，只能通过内核的“消息传递”间接通信

5. 外核

​	内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全
优点：

* 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源
* 减少了虚拟硬件资源的“映射层”，提升效率

缺点：

* 降低了系统的一致性
* 使系统变得更复杂

![image-20210806095502046](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806095502046.png)

### 1.5 操作系统引导

* ==激活cpu==--激活的cpu读取ROM中的boot程序，将指令寄存器置为BIOS的第一条指令（开始执行BIOS的指令）
* 硬件自检--BIOS程序在内存最开始的空间构建中断向量表，接下来的POST过程要用到中断功能

* ==加载带有操作系统的硬盘==。通电自检后，BIOS开始读取Boot Sequence（通过CMOS里保存的 启动程序，或者通过与用户交互的方式），将控制权交给启动顺序排在第一位的存储设备，然后cpu将该存储设备引导扇区的内容加载到内存中

* ==加载主引导记录（MBR）==。硬盘以特定的标识符区分引导硬盘和非引导硬盘，MBR的作用是告诉cpu去硬盘的哪个主分区去找操作系统。
* ==扫描硬盘分区表==，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区--有操作系统的分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。
* ==加载分区引导记录（PBR）==。读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并己获分区根目录下用于引导操作系统的程序（启动管理器）
* 加载启动管理器
* 加载操作系统

​	MBR是磁盘的第一个扇区、它不属于任何的磁盘分区；而PBR位于磁盘活动分区的第一个扇区。

### 1.6 虚拟机

#### 1.6.1 虚拟机的基本概念

* 第一类虚拟机管理程序

​	这个就像操作系统，它是唯一一个运行在最高特权级的程序。他在裸机上运行并且具备

多道程序功能，该管理程序向上提供若干虚拟机，可以运行不同的操作系统。

​	虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统任务自己运行在内核态，实际上是虚拟内核态。==当虚拟机执行了一条cpu处于内核态才能执行的指令时，会陷入虚拟机管理程序。==在支持虚拟化的cpu上，虚拟机管理程序检查这条指令是由虚拟机虚拟机中的操作系统执行还是由用户程序执行。前者--安排这条指令的正确执行；后者--模拟硬件面对用户态执行敏感指令时的行为。

* 第二类虚拟机管理程序

​	就是VMware之类的虚拟机程序，该管理程序运行在宿主操作系统之上，管理客户操作系统

## 2 进程

### 2.0 考纲内容

* 进程和线程
  * 基本概念、状态与转换、线程的实现、内核支持的线程、线程库支持的线程、进程和线程的组织与控制、进程间通信：共享内存、消息传递、管道
* cpu调度与上下文切换
  * 调度的基本概念；目标；调度的实现：调度器/调度程序，调度的时机与调度方式（抢占式/非抢占式），闲逛进程，内核级线程与用户级线程调度
  * 典型调度算法
  * 上下文切换及其机制
* 同步和互斥
  * 同步与互斥的基本概念
  * 基本的实现方法：软件方法、硬件方法
  * 锁：信号量、条件变量
  * 经典同步问题：生产者-消费者；读者-写者，哲学家进餐
* 死锁
  * 死锁的基本概念；死锁预防
  * 死锁避免；死锁检测和解除

### 2.1 进程与线程

#### 2.1.1 进程的概念和特征

1. 进程的概念

​	多道程序环境下，运行多个程序并发执行，此时失去了封闭性，并具有间断性及不可再现性的特征。

​	==进程实体（进程映像）==由程序段、相关数据段、PCB构成

​	当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— ==PID==（Process ID，进程ID）

​	这些信息都被保存在一个数据结构==PCB==（Process Control Block）中，即==进程控制块==操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中

* 进程的定义：进程实体的运行过程，是系统进行资源分配和调度的一个独立单位；==程序的一次执行过程==；同一个程序多次执行会对应多个进程

2. 进程的特征

* 动态性--进程是程序的一次执行，有着创建、活动、暂停、终止等过程，具有一定生命周期，是==最基本的特征==
* 并发性--指多个进程同存于内存中，一段时间内同时运行
* 独立性--进程是一个能独立运行、独立获得资源和接受调度的基本单位
* 异步性--进程间的相互制约，使得各进程按各自独立的、不可预知的速度向前推进，会导致结果的不可再现性

#### 2.1.2 进程的组成

![image-20210806102114288](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806102114288.png)

PCB常驻内存，任意时刻都可以存取，并且在进程结束时删除。PCB是进程实体的一部分，是进程存在的==唯一标志==

![image-20210806102043843](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806102043843.png)

注：

* 进程控制和管理信息还包括：进程优先级--描述进程抢占cpu的优先级，优先级高的进程可先获得cpu
* 处理机相关信息（cpu的上下文）：主要指cpu中各寄存器的值

#### 2.1.3 进程的状态与转换

![image-20210806104039442](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210806104039442.png)

注：运行态到阻塞态是主动行为；阻塞态到就绪态是被动的

#### 2.1.4 进程控制

==进程控制就是要实现进程状态转换==

- 如何实现==进程控制==？

  用“==原语==”实现

  原语的执行具有“原子性”，一气呵成

- 如何实现原语的“原子性”？

  原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性

1. 进程的创建

​	允许一个进程创建另一个进程，子进程可以继承父进程所拥有的资源，子进程被撤销的时候，应将其从父进程那里获得的资源还给父进程。撤销父进程，子进程也会撤销。

​	事件：用户登录，作业调度，提供服务，应用请求

​	创建时的操作：分配PID，申请一个空白PCB；为进程分配其运行所需要的资源（文件、内存、I/O设备、cpu时间）（如果资源不足，就会在创建态等等待内存资源）；初始化PCB；若进程就绪队列能够接纳新进程，调入就绪队列

2. 进程的终止

​	事件：正常结束、异常结束、外界干预

​	终止进程的过程：根据PID检索PCB，读出进程状态；若被终止进程处于运行状态，立刻终止该进程的执行，将cpu资源分配给其他进程；如果还有子孙进程，通常需要终止子孙进程；将进程所拥有的全部资源归还给父进程或操作系统；将PCB从队列中删除

3. 进程的阻塞和唤醒

* 阻塞态（block）是==暂时==停止运行，比如等待IO操作，等待其他进程配合
  * 根据PID找到PCB；如果是运行态，就保护现场，转为阻塞态，停止运行；PCB插入相应事件的等待队列，将PCB资源给其他就绪进程

* 唤醒（wake up）是等待的事件发生就从阻塞到就绪态
  * 找到PCB，移除等待队列置为就绪态；插入就绪队列等待调度

#### 2.1.5 进程的通信

![image-20210809091958835](https://github.com/cen6667/408/raw/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/image-20210809091958835.png)

进程通信就是指进程之间的==信息交换==。 进程是分配系统资源的单位（包括内存地址空间），因此==各进程==拥有的==内存地址空间相互独立==。

为了保证安全，==一个进程不能直接访问另一个进程的地址空间==。

* **共享存储**

==基于数据结构==的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式 ==基于存储区==的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

* **管道通信**

数据以字符流的形式写入管道，当管道==写满==时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部==取走后==，管道==变空==，此时读进程的read（）系统调用将被阻塞。

如果==没写满，就不允许读==。如果==没读空，就不允许写==。

数据==一旦被读出，就从管道中被抛弃==，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

* **消息传递**

进程间的数据交换以==格式化的消息==（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个==原语==进行数据交换。

间接通信：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。

#### 2.1.6 线程和多线程模型

1. 线程的基本概念

​	可以把线程理解为“==轻量级进程==”。 线程是一个==基本的CPU执行单元==，也是==程序执行流的最小单位==。

* 引入线程之后，不仅是进程之间可以并发，==进程内的各线程之间也可以并发==，从而进一步提升了系统的==并发度==，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）

* 引入线程后，==进程==只作为除CPU之外的==系统资源的分配单元==（如打印机、内存地址空间等都是分配给进程的）。==线程==则作为==处理机的分配单元==。

2. 进程和线程的比较































