# **数据结构二轮**

## 1 线性表

### 1.0 考纲内容

* 线性表的基本概念

* 现象表的实现（顺序存储，链式存储）

* 线性表的应用

### 1.1 线性表的定义和操作

#### 1.1.1 线性表的定义

==线性表==是具有相同数据类型的n个数据元素的==有限序列==

特点如下：

* 元素个数==有限==
* 具有逻辑上的顺序，表中元素具有==先后次序==
* 是数据元素，单个元素
* ==数据类型都相同==，占相同的存储空间
* 表中元素具有抽象性

#### 2.1.2 线性表的基本操作

`Initlist(&L)` :初始化表——构造一个空的线性表

`Length(L)` : 求表长——返回线性表L的长度，即L中数据元素的个数

`LocateElem(L,e)` : 按值查找操作——在表L中查找具有给定关键字的值

`ListInsert(&L,i,e)` : 插入操作——在表中第 i 个位置的元素的值

`ListDelete(&L,I,&e)` : 删除操作——删除表L中第 i 个位置的元素，并用 e 返回删除元素的值

`PrintList(L)` : 输出操作——按照前后顺序输出线性表L的值

`Empty(L)` : 判空操作——若L为空，返回true，否则返回false

`DestoryList(&L)` : 销毁操作——销毁线性表，并且释放线性表L所占用的内存空间

### 1.2 线性表的顺序表示

#### 1.2.1 顺序表的定义

线性表的顺序存储又称顺序表。他是用一组==地址连续的存储单元==依次存储线性表中的数据元素，从而是的逻辑（编程）上相邻的元素在物理（内存）位置上也相邻。

顺序表的特点是表中元素的逻辑顺序与其物理存储顺序相同。因此顺序表支持==随机存取==。通常用高级语言的数组来描述线性表的顺序存储结构。

<!--数组下标从0开始，线性表元素位序从1开始-->

* 静态分配的顺序表存储结构描述为

```c
#define Maxsize 50
typedef struct {
    ElemType data [Maxsize]; //顺序表的元素
    int length; //顺序表的当前长度
}SqList; //顺序表的类型定义
```

一维数组可以是静态、动态分配。

* 动态分配的顺序表的存储结构描述为

```c
#define InitSize 100
typedef struct {
    ElemType *data;
    int Maxsize,length;
}SeqList;
```

C的初始动态分配语句

```c
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```

#### 1.2.2 顺序表上基本操作的实现

1. 顺序表的初始化

   ```c
   //静态初始化
   //SqList L;
   void InitList(SqList &L){
       L.length = 0;
   }
   ```

   ```c
   //动态初始化
   void InitList(SeqList &L){
       L.data = (ElemType *)malloc(InitSize*sizeof(ElemType));
       L.length = 0;
       L.MaxSize = InitSize;
   }
   ```

   ---

2. 插入操作
   最好情况：O(1)；最坏情况：O(n)；平均：O(n)

   ```c
   bool InsertList(SeqList &L,int i,int e)
   {
       if(i<1 || i>L.Length+1)
           return false;
       if(L.Length >= L.Maxsize)
       {
         return false;
       }
       for(int j = L.Length; j>=i; j--)
       {
           L.data[j] = L.data[j-1];
       }
       L.data[i-1] = e;
       L.Length++;
       return true;
   }
   ```

   ---

3. 删除操作
   最好情况：O(1)；最坏情况：O(n)；平均：O(n)

   ```c
   bool DeleteList(SeqList &L,int i,int &e)
   {
       if(i < 1 || i > L.Length + 1)
           return false;
       e = L.data[i-1];
       for(int j = i; j<L.Length; j++)
       {
           L.data[j-1] = L.data[j];
       }
       L.Length--;
       return true;
   }
   ```

   ---

4. 按值查找（顺序查找）

   最好情况：O(1)；最坏情况：O(n)；平均：O(n)

   ```c
   int LocateElem(SeqList L,int e)
   {
       for(int i = 0; i<L.Length; i++)
       {
           if(L.data[i] == e)
               return i+1;
       }
       return 0;
   }

---

5. 其他操作

   ```c
   int Length(SeqList L)
   {
       return L.Length;
   }
   
   int GetElem(SeqList L,int i)
   {
       for(int j = 0; j<L.Length; j++)
       {
           if(j+1 == i)
               return L.data[j];
       }
       return 0;
   }
   
   //输出顺序表
   void PrintList(SeqList L)
   {
       for(int i = 0; i<L.Length; i++)
       {
           printf("%d ",L.data[i]);
       }
       printf("\n");
   }
   
   //建立顺序表
   void createList(SeqList &L)
   {
       int e;
       printf("请输入顺序表的元素(输入-1结束):\n");
       InitList(L);
       while(true)
       {
           scanf("%d",&e);
           if(e == -1)
               break;
           InsertList(L,L.Length+1,e);
       }
   }
   ```

​	[控制台版线性表地址](https://github.com/Xiaoliangya/C_DS/blob/master/List.cpp)

### 1.3 线性表的链式表示

通过==链==来建立元素之间的逻辑关系。链表的插入删除不需要移动元素，但是失去了随机存取的特性。

#### 1.3.1 单链表的表示

为了建立数据元素之间的线性关系，对于每个链表结点，除了存放元素自身的信息之外，还需要存放一个指向其后继的指针。

结点定义描述如下：

```c
typedef struct Node
{
    int data;
    struct Node *next;
} Node, *LinkList;
```

#### 1.3.2 单链表操作的实现

```c
// 初始化链表,这是带头结点的链表
bool InitList(LinkList &L)
{
    L = (LinkList)malloc(sizeof(Node));
    L->next = NULL;
    return true;
}

// //不带头结点的链表
// bool InitList(LinkList &L)
// {
//     L = NULL;
//     return true;
// }

// 求链表长度
int Lenth(LinkList L)
{
    int len = 0;
    Node *p = L;
    while (p->next != NULL)
    {
        len++;
        p = p->next;
    }
    return len;
}

// 按序号查找结点
Node *GetElem(LinkList L, int index)
{
    LinkList p = L;
    int i = 0;
    while (p != NULL && i < index)
    {
        p = p->next;
        i++;
    }
    return p;
}

// 按值查找结点
Node *SearchElem(LinkList L, int value)
{
    Node *p = L->next;
    while (p != NULL && p->data != value)
        p = p->next;
    return p;
}

// 插入结点
bool InsertElem(LinkList &L, int index, int value)
{
    Node *p = L;
    int i = 0;
    while (p != NULL && i < index - 1)
    {
        p = p->next;
        i++;
    }
    if (p == NULL)
        return false;
    Node *s = (Node *)malloc(sizeof(Node));
    s->data = value;
    s->next = p->next;
    p->next = s;
    return true;
}

// 删除结点
bool DeleteElem(LinkList &L, int index)
{
    Node *p = L;
    int i = 0;
    while (p != NULL && i < index - 1)
    {
        p = p->next;
        i++;
    }
    if (p == NULL)
        return false;
    Node *q = p->next;
    p->next = q->next;
    free(q);
    return true;
}

// 头插法建立链表
LinkList HeadInsertElem(LinkList &L)
{
    InitList(L);
    int value;
    printf("请输入结点值(-1结束):\n");
    scanf("%d", &value);
    while (value != -1)
    {
        InsertElem(L, 1, value);
        scanf("%d", &value);
    }
    return L;
}

// 尾插法建立链表
LinkList TailInsertElem(LinkList &L)
{
    InitList(L);
    int value;
    Node *p, *s=L;
    printf("请输入结点值(-1结束):\n");
    scanf("%d", &value);
    while (value != -1)
    {
        p = (Node *)malloc(sizeof(Node));
        p->data = value;
        s->next = p;
        s = p;
        scanf("%d", &value);
    }
    s->next = NULL;
    return L;
}

// 打印链表
void PrintList(LinkList L)
{
    Node *p = L->next;
    while (p != NULL)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}
```

[控制台版](https://github.com/Xiaoliangya/C_DS/blob/master/Linklist.cpp)

#### 1.3.3 双链表

和单链表的主要区别是：单链表只能从前往后访问，如果要访问前驱只能从头开始，时间复杂度为O(n);双链表具有指向前驱的指针。

```c
typedef struct DNode{
    int data;
    struct DNode *piror, *next;
}DNode, *DLinkList;
```

* 双链表的插入操作

```c
s->next = p->next;
p->next->piror = s;
s->piror = p;
p->next = s;
```

* 双链表的删除操作

```c
p->next = s->next;
s->next->piror = p;
free(q);
```

#### 1.3.4 循环列表

1. 循环单链表

​	表中最后一个结点的指针不是NULL，是指向头结点，从而形成一个环。

​	 					<img src="https://img-blog.csdnimg.cn/20200211183436721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE5MzgxMw==,size_16,color_FFFFFF,t_70" alt="循环列表" style="zoom:50%;" />

​	如果对循环单链表设置尾指针可以很方便的在头、尾增加结点，时间复杂度O(1)

2. 循环双链表

<img src="https://img-blog.csdnimg.cn/20200727110019517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plYXRlbg==,size_16,color_FFFFFF,t_70" alt="循环双列表" style="zoom: 33%;" />

#### 1.3.5 静态链表

是用==数组==来描述线性表的链式存储结构，结点也有数据域和指针域，这里的指针是结点在数组中的相对地址（数组下标），也叫游标。静态链表也要预分配内存。

<img src="https://img-blog.csdnimg.cn/20210418162136494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjM2MQ==,size_16,color_FFFFFF,t_70" alt="静态列表" style="zoom: 80%;" />

## 2 栈、队列和数组

### 2.0 考纲内容

* 栈和队列的基本概念
* 栈和队列的顺序存储结构
* 栈和队列的链式存储结构
* 多维数组的存储
* 特殊矩阵的压缩存储
* 栈、队列和数组的应用

### 2.1 栈

#### 2.1.1栈的定义

栈是一种==受限线性表==，只能在某一段进行插入和删除操作

<img src="https://img-blog.csdnimg.cn/c3856ee189ab4a21a46c4f44bdcffe2c.png" alt="栈" style="zoom: 33%;" />

* 栈顶：允许进行插入删除的一端
* 栈底：不允许进行插入删除的一段
* 空栈：不含任何元素的空表

栈的操作特性==后进先出==

**基本操作**：

`InitStack(&S)`：初始化一个空栈

`StackEmpty(S)`：判断一个栈是否为空，空就返回true；否则返回false

`Push(&S,x)`：栈未满则进栈

`Pop(&S,&x)`：栈非空则出栈

`GetTop(S,&x)`：读栈顶元素

`DestroyStack(&S)`：销毁栈

n个元素进栈，出栈元素不同排列的个数为：[卡特兰数](https://cn.bing.com/images/search?view=detailV2&ccid=LJ1vo59J&id=1F775445260F26053173033CCA225E725704D3D3&thid=OIP.LJ1vo59JFYZStzYAXdSgRAHaBO&mediaurl=https%3a%2f%2fimg-blog.csdnimg.cn%2f2b084ca96d65411f83c5f206b5937b89.png%23pic_center&exph=145&expw=880&q=%e5%8d%a1%e7%89%b9%e5%85%b0%e6%95%b0%e5%85%ac%e5%bc%8fLATEX&simid=608020585215368386&FORM=IRPRST&ck=06F8CD281E6B6912614DF336D13323D6&selectedIndex=27&itb=0)

#### 2.1.2 栈的顺序存储结构

栈是一种操作受限的线性表，类似于线性表，也有两种存储方式

1. 顺序栈的实现

```c
typedef struct
{
    int data[MaxSize];
    int top;
} SqStack;
```

2. 栈的基本操作

* 初始化

```c
void InitStack(SqStack &S)
{
    S.top = -1; //指向栈顶
}
```

* 判栈空

```c
bool StackEmpty(SqStack S)
{
    return S.top == -1;
}
```

* 进栈

```c
bool Push(SqStack &S, int x)
{
    if (S.top == MaxSize - 1)
    {
        return false;
    }
    S.data[++S.top] = x;
    return true;
}
```

* 出栈

```c
bool Pop(SqStack &S, int &x)
{
    if (S.top == -1)
    {
        return false;
    }
    x = S.data[S.top--];
    return true;
}
```

* 读栈顶元素

```c
bool GetTop(SqStack S, int &x)
{
    if (S.top == -1)
    {
        return false;
    }
    x = S.data[S.top];
    return true;
}
```

[控制台版栈](https://github.com/Xiaoliangya/C_DS/blob/master/Stack.cpp)

3. 共享栈

   两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在两端[0]、[MaxSzie-1],同时设置两个指针，栈满条件：top1-top0=1

#### 2.1.3 栈的链式存储结构

```c
typedef struct LinkNode{
    int data;
    struct LinkNode *next;
}LiStack;
```

### 2.2 队列

#### 2.2.1 队列的基本概念

1. 定义

​	也是受限的线性表，==只允许在一端插入，另一端删除==，特性是==先进先出==

![队列](https://th.bing.com/th/id/OIP.H8te3TkocZ3Q39OKjOFvlwHaC8?rs=1&pid=ImgDetMain)

* 队头：允许删除
* 队尾：允许插入

#### 2.2.2 队列的顺序存储结构

1. 队列的顺序存储

```c
#define MaxSize 50
typedef struct{
    int data[MaxSize];
    int front,rear;
}SqQueue;
```

​	初始时：Q.front = Q.rear = 0

​	进队操作：队不满，先送值到队尾，然后队尾指针加1

​	出队操作：队不空，先取对头元素值，再将队头指针加1

2. 循环队列

* 初始时：Q.front = Q.rear = 0
* 队首指针进1：Q.front = (Q.front + 1) % MaxSize
* 队尾指针进1：Q.rear = (Q.rear + 1) % MaxSize
* 队列长度：(Q.rear + MaxSize - Q.front) % MaxSize

判断队空、队满

​		1. 牺牲一个单元来区分队空和队满，入队时少用一个队列单元

​		`队头指针在队尾指针的下一位置作为队满的标志`

​		`队满：(Q.rear + 1) % MaxSize == Q.front`

​		`队空：Q.front == Q.rear`

​		`元素个数：(Q.rear - Q.front + MaxSize) % MaxSize`

<img src="https://img-blog.csdnimg.cn/20200214191323871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGlsaWxpbGlsaWtp,size_16,color_FFFFFF,t_70" alt="队列" style="zoom: 33%;" />

​		2. 用一个Size变量表示元素个数

​		3. 用一个tag变量区分栈满/栈空——删除成功则tag = 0，插入成功则tag = 1

3. 循环队列的操作

​	初始化：

```c
void InitQueue(SqQueue &Q) {
    Q.front = Q.rear = 0;
}
```

​	判断队空：

```c
bool isEmpty(SqQueue Q) {
    if(Q.front == Q.rear)
        return true;
    else
        return false;
}
```

​	入队：

```c
bool EnQueue(SqQueue &Q, int x) {
    if((Q.rear+1)%MAX_SIZE == Q.front)
        return false;
    else {
        Q.rear = (Q.rear+1)%MAX_SIZE;
        Q.data[Q.rear] = x;
        return true;
    }
}
```

​	出队：

```c
bool DeQueue(SqQueue &Q, int &x) {
    if(Q.front == Q.rear)
        return false;
    else {
        x = Q.data[Q.front];
        Q.front = (Q.front+1)%MAX_SIZE;
        return true;
    }
}
```

[控制台版](https://github.com/Xiaoliangya/C_DS/blob/master/Queue.cpp)

#### 2.2.3 队列的链式存储结构

```c
typedef struct LinkNode{
    int data;
    struct LinkNode *next;
}LinkNode;
typedef struct {
    LinkNode *front,*rear;
}LinkQueue;
```

不带头结点时，当Q.front == NULL且Q.rear == NULL时，链式队列为空

==一般将链式队列设置为带头结点的单链表==

```c
void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));//头结点
    Q.front->next = NULL;
}

bool isEmpty(LinkQueue Q) {
    return (Q.front->next == NULL);
}

void EnQueue(LinkQueue &Q, int x) {
    LinkNode *p = (LinkNode *)malloc(sizeof(LinkNode));
    p->data = x;
    p->next = NULL;
    Q.rear->next = p;
    Q.rear = p;
}                                                               

void DeQueue(LinkQueue &Q) {
    if (isEmpty(Q)) {
        printf("Queue is empty!\n");
        return;
    }
    LinkNode *p = Q.front->next;
    Q.front->next = p->next;
    if (Q.rear == p) {
        Q.rear = Q.front;
    }
    free(p);
}
```

[链式队列](https://github.com/Xiaoliangya/C_DS/blob/master/LinkQueue.cpp)

#### 2.2.4 双端队列

两边都可以进出的队列，一端受限的双端队列

### 2.3 栈和队列的应用

#### 2.3.1 栈在括号匹配的应用

[括号匹配](https://github.com/Xiaoliangya/C_DS/blob/master/Stack_bracket.cpp)

#### 2.3.2 栈在表达式求值中的应用

中缀表达式是人们常用的算术表达式，但是计算机容易解析的是前缀、后缀表达式

* 中缀->后缀

​	手工方法：将中缀表达式写成中序遍历的二叉树，然后按照后序遍历得出结果

​	计算机解析： 遇到==操作数==直接加入表达式

​				遇到==界限符==，“(”入栈，“）”依次弹出栈中运算符并加入表达式，直到“（”出栈

​				遇到==运算符==，优先级高于括号，入栈，否则，从栈顶依次弹出优先级>=当前运算符的所有运算符，直到优先级低于当							前运算符或者“（”

[中缀表达式示例](https://img-blog.csdnimg.cn/a98142ec023041868d531273e005ba63.png)

<img src="https://github.com/Xiaoliangya/C_DS/blob/master/png.jpg?raw=true" alt="后缀表达式求值" style="zoom: 25%;" />

#### 2.3.3 栈在递归中的应用

* 斐波拉契数列

```c
int F(int n){
	if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else return F(n-1)+F(n-2);
}
```

#### 2.3.4 栈在层次遍历中的应用

* 根节点入队
* 队空，结束遍历；否则重复下一步
* 队列第一个结点出队并访问，有左孩子，将左孩子入队；有右孩子，右孩子入队

#### 2.3.5 栈在计算机中应用

* 缓冲区
* CPU竞争

### 2.4 数组和特殊矩阵

#### 2.4.1 数组

定义：由 n 个相同类型的数据元素构成有限序列，每个数据元素称为一个数组元素，每个元素在 n 个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的==维界==。（下标从0开始，位序从1开始）

* 数组与线性表的关系：数组是线性表的推广
  * 一维数组：可视为线性表
  * 二维数组：可视为其元素是定长线性表的线性表

#### 2.4.2 数组的存储结构

* 一个数组的所有元素在内存中占用一段连续的存储空间。

​	以一维数组 A[0..n-1]为例，其存储结构关系式为：![数组](https://latex.csdn.net/eq?LOC%28a_%7Bi%7D%29%3DLOC%28a_%7B0%7D%29&plus;i%5Ctimes%20L%280%5Cleqslant%20i%5Cleqslant%20n%20%29)

* 对于多维数组，有两种映射方法:按行优先和按列优先。

​	以二维数组为例，按行优先存储的基本思想是:先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。

​	设二维数组的行下标与列下标的范围分别为[0,h1]与[0,h2]，则存储结构关系式为：										      					![行优先](https://latex.csdn.net/eq?LOC%28a_%7Bi%2Cj%7D%29%3DLOC%28a_%7B0%2C0%7D%29&plus;%5Bi%5Ctimes%20%28h_%7B2%7D&plus;1%29&plus;j%5D%5Ctimes%20L)

​	当以列优先方式存储时，得出存储结构关系式为:![列优先](https://latex.csdn.net/eq?LOC%28a_%7Bi%2Cj%7D%29%3DLOC%28a_%7B0%2C0%7D%29&plus;%5Bj%5Ctimes%20%28h_%7B1%7D&plus;1%29&plus;i%5D%5Ctimes%20L)

#### 2.4.3 特殊矩阵的压缩存储

==压缩存储==是指对多个值相同的元素只分配一个存储空间，对零元素不分配空间

* 对称矩阵

对称矩阵是指以主对角线为轴的对换，其特点是在一个n阶方阵中，有a~ij~==a~ji~，其中i>=1，j<=n。下图所示是一个5阶对称矩阵。

​						[![11111](https://user-images.githubusercontent.com/33026710/37641303-2db4854c-2c54-11e8-8a11-b156ac12f6cc.jpg)](https://user-images.githubusercontent.com/33026710/37641303-2db4854c-2c54-11e8-8a11-b156ac12f6cc.jpg)
结论：（下标从0开始，且是下三角区，若要上三角区，i、j互换即可）
$$
k=i(i-1)/2+j-1
$$

* 三角矩阵
* 三对角矩阵

#### 2.4.4 稀疏矩阵

* 三元组

![三元组](https://i-blog.csdnimg.cn/blog_migrate/8c3c4f069dab8b2577084f1642b6e6cb.gif)

* 十字链表

![十字链表](https://i-blog.csdnimg.cn/blog_migrate/d5bcd8014de149e9f9b5d4e596f2e54a.gif)

## 3 串

### 3.0 考纲内容

字符串的模式匹配

### 3.1 串的定义和实现

#### 3.1.1 串的定义

​	`S = ‘a1a2a3…an’` 

S是串名，里面字符序列是串的值，ai可以是字母、数字或者其他字符，个数n是串的长度，n=0是是空串

### 3.2 串的模式匹配

#### 3.2.1 简单的模式匹配算法

```c
int Index(SString S, SString T)
{
    int i = 1, j = 1;
    while(i <= S.len && j <= T.len) {
        if(S.str[i] == T.str[j])
            ++i, ++j;
        else
            i = i - j + 2, j = 1;
        if(j > T.len)
            return i - T.len;
    }
    return 0;
}
```

<img src="https://i-blog.csdnimg.cn/blog_migrate/264334fb9012c29053a4d90600c6f126.png#pic_center" alt="串" style="zoom:50%;" />

时间复杂度为O(mn)

#### 3.2.2 KMP算法

1. 前缀：除最后一个字符外，所有头部子串
2. 后缀：除第一个字符外，所有尾部子串
3. 部分匹配值：前缀后缀最长相等前后缀长度

​	根据 ‘ababa’ 解释

* ‘a’，前后缀空集，最长相等前后缀长度为0
* ‘ab’，前缀为{a}，后缀为{b}，最长相等前后缀长度为0
* ‘aba’，的前缀为{a，ab}，后缀为{b，ba}，最长相等前后缀长度为1
* ‘abab’，长度为2
* ‘ababa’，长度为3

​	因此，’ababa‘的部分匹配值为00123

| 编号 | 1    | 2    | 3    | 4    | 5    |
| :--: | ---- | ---- | ---- | ---- | ---- |
|  S   | a    | b    | c    | a    | c    |
|  PM  | 0    | 0    | 0    | 1    | 0    |

==移动位数== = 已匹配的字符数 - 对应的部分匹配值(最后一个匹配字符的PM)

时间复杂度为O(m+n)

==改进==：Move = (j - 1) - PM[j- 1]（next[j]），即将PM表右移一位，第一个元素用-1

​	因为使用部分匹配值时，每当匹配失败，就去找前一个元素的部分匹配值，这样不太方便所以将PM表右移一位，得到next数组

* 要会求next【j】和nextval【j】数组

## 4 树

### 4.0 考纲内容

* 基本概念
* 二叉树定义、特性、遍历、存储结构、线索二叉树构造
* 树、森林
* 树和二叉树的应用

### 4.1 树的基本概念

#### 4.1.1 树的定义

n(n>=0)个结点的有限集，n=0时，是空树

非空树：有且仅有一个根节点并且其余结点可以分为m个互不相交的有限集，每个集合本身又是一棵树，称为根的子树

所以==书的定义是递归的==：

* 根节点没有前驱，除根节点外所有节点有且只有一个前驱
* 树中所有结点都可以有0个或者多个后继（n个结点有n-1条边）

#### 4.1.2 基本术语

* 祖先、子孙、双亲、孩子、兄弟、堂兄弟
* 结点的度和树的度：树中一个结点的孩子个数称为该==结点的度==，树中结点的最大度数称为==树的度==
* 分支结点（度大于0）、叶结点（度为0）
* 结点的深度、高度、层次：树的高度（深度）是树中结点的最大层数，==层次从根节点开始定义==，结点的高度是以该结点为根的子树的高度
* 有序、无序树：树中结点的各子树从左到右是有次序的，不能互换，称为有序树，否则无序树
* 路径长度：经过的边个数
* 森林：m颗不相交树的集合

#### 4.1.3 树的性质

* 结点树n = 所有结点的度数之和加1（一个度对应一个孩子结点对应一条边）
* 度为m的树中第i层上至多有m^i-1^
* 高度为h的m叉树至多有(m^h^-1)/(m-1)个结点
* 度为m，具有n个结点最小高度⌈ log~m~(n(m-1)+1) ⌉
* 度为m，具有n个结点的树最大高度h为n-m+1

### 4.2 二叉树的概念

#### 4.2.1 二叉树的定义及其主要特性

1. 定义：每个结点最多只有==2颗==子树（度<=2），且有左右之分，次序不能颠倒

* 树的定义也是递归实现的，二叉树是n（n>=0）个结点的有限集合
  * 空二叉树（n = 0）
  * 由一个根结点和两不互不相交的被称为根的左子树和右子树组成，左子树和右子树又分别是一颗二叉树
* 二叉树的基本形态：

​	![二叉树基本形态](https://i-blog.csdnimg.cn/blog_migrate/2bd2cad4ee506fe34fc222084340dca5.png)

2. 特殊的二叉树：
   * 满二叉树：高度为h，且有2^h^-1个结点的二叉树，每层含有最多的结点
   * 完全二叉树：高度为h，有n个结点，当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应
     * i<=⌊ n/2 ⌋时为分支结点、否则为叶结点
     * 叶结点只会出现在层次最大的两层
     * 度为1的结点最多只有一个，不会出现只有一个右孩子的情况
     * 某结点 i 只有左孩子则 > i的结点都是叶结点
   * 二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树均大于根结点
   * 平衡二叉树：任意一个结点的左子树和右子树的高度之差绝对值不超过1
   * 正则二叉树：每个结点的度只能是2/0
3. 二叉树的性质

* 非空二叉树上叶结点树等于度为2的结点数 + 1；即n~0~ = n~2~ + 1
* 非空二叉树的第k层最多有2^k-1^个结点
* 高度为h的二叉树至多有2^h^-1个结点
* 对于完全二叉树按从上到下、从左到右编号1，2，3……n
  * i<=⌊ n/2 ⌋时为分支结点、否则为叶结点
  * 叶结点只会出现在层次最大的两层
  * 度为1的结点最多只有一个，不会出现只有一个右孩子的情况
  * 某结点 i 只有左孩子则 > i的结点都是叶结点
  * i > 1时，结点 i 的双亲结点编号为⌊ i/2 ⌋
  * 结点 i 的左孩子是2i，右节点是2i+1
  * 结点i所在层次为⌊ log~2~i ⌋ + 1
* 具有n个结点的完全二叉树高度为⌊ log~2~n ⌋ + 1或者⌈ log~2~(n+1) ⌉

#### 4.2.2 二叉树的存储结构

1. 顺序存储结构：用一组连续的存储单元自上而下、自左而右存储完全二叉树上的结点元素，即结点序号为1的元素存储在一维数组下标为i-1的分量中；适用于：完全二叉树、满二叉树

​	对于一般的二叉树，需要添加一些并不存在的空结点   ==缺点==：空间利用率低

2. ==链式存储结构==：二叉链表至少包含3个域：`data`、`lchild`、`rchild`

```c
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
```

### 4.3 二叉树的遍历和线索二叉树

#### 4.3.1 二叉树的遍历

1. 先序遍历

```c
void PreOrder(BiTree T)
{
    if( T!= NULL)
    {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
```

2. 中序

```c
void InOrder(BiTree T)
{
    if( T!= NULL)
    {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}
```

3. 后序

```c
void PostOrder(BiTree T)
{
    if( T!= NULL)
    {
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
```

4. 递归和非递归算法的转换（借助栈）

* 中序：

```c
void InOrder(BiTree T)
{
	SqStack* S;
	S = InitStack();
	BiTreeNode* p;
	p = T;
	while (p || !StackEmpty(*S))
	{
		if (p)
		{
			Push(S, p);
			p = p->LChild;
		}
		else
		{
			Pop(S, &p);
			printf("%c", p->data);
			p = p->RChild;
		}
	}
}
```

* 先序：

```c
void PreOrder(BiTree T)
{
	SqStack* S;
	S = InitStack();
	BiTreeNode* p;
	p = T;
	while (p|| !StackEmpty(*S))
	{
		if (p)
		{
			printf("%c",p->data);
			Push(S, p);
			p = p->LChild;
		}
		else
		{
			Pop(S, &p);
			p = p->RChild;
		}
	}
}
```

* 后序：出栈的元素保证左右子树都被访问

```c
void Postorder(BiTree T)
{
	SqStack* S;
	S = InitStack();
	BiTreeNode* p;
	p = T;
	char tag[Maxsize] = {'0'};
	while (p || !StackEmpty(*S))
	{
		if (p)
		{
			Push(S, p);
			tag[S->top] = '0';//标志结点是否遍历右子树
			p = p->LChild;
		}
		else
		{
			while (tag[S->top] == '1') {
				Pop(S, &p);
				printf("%c",p->data);
			}
			if (S->top == -1) break;
			Pop(S, &p);
			Push(S, p);
			p = p->RChild;
			tag[S->top] = '1';
		}
		

	}
}
```

5. 层次遍历：需要借助队列

```c
void Levelorder(BiTree T)
{
	BiTree Q[Maxsize];
	int front, rear;
	if (T == NULL)return;
	front = -1;
	rear = 0;
	Q[rear] = T;
	while (front != rear)
	{
		front++;
		printf("%c",Q[front]->data);
		if (Q[front]->LChild != NULL)
		{
			rear++;
			Q[rear] = Q[front]->LChild;
		}
		if (Q[front]->RChild != NULL)
		{
			rear++;
			Q[rear] = Q[front]->RChild;
		}
	}
}
```

6. 遍历序列构造二叉树：一定要已知==中序序列==
   [二叉树](https://github.com/Xiaoliangya/C_DS/blob/master/BiTree.cpp)  [递归遍历](https://github.com/Xiaoliangya/C_DS/blob/master/BiTree_Stack.cpp)

#### 4.3.2 线索二叉树

1. 基本概念：由于每个叶结点都有2个空指针、每个度为1的结点都有1个空指针，空指针总数为2n~0~+n~1~,又n~0~=n~2~+1

   则空指针总数为n~0~+n~1~+n~2~+1=n+1  ==引入线索二叉树为了加快查找结点前驱和后继的速度

​	规定：无左子树，令lchild指向其前驱结点，无右子树，令rchild指向其后继结点，用标志域表示指向孩子还是前驱/后继

​	`ltag=0(左孩子);1(前驱)`  	理解记忆：这是线索树，`ltag = 1`表示线索有效，所以指向前驱

​	`rtag=0(右孩子);1(后继)`

定义：

```c
typedef struct ThreadNode {
    int data;
    struct ThreadNode* lchild, *rchild;
    int ltag, rtag;
}ThreadNode, *ThreadTree;
```

2. 构造

```c
void Inthread(ThreadTree &p, ThreadTree &pre) {
    if (p != NULL) {
        // 递归左子树进行线索化
        Inthread(p->lchild, pre);
        // 左指针为空，建立前驱线索
        if (p->lchild == NULL) {
            p->lchild = pre;    // 当前节点的左指针指向前驱
            p->ltag = 1;        // 标记为线索
        }       
        // 右指针为空，前驱的右指针指向当前节点
        if (pre != NULL && pre->rchild == NULL) {
            pre->rchild = p;    // 前驱的右指针指向当前节点
            pre->rtag = 1;      // 标记为线索
        }        
        // 更新前驱为当前节点
        pre = p;
        // 递归右子树进行线索化
        Inthread(p->rchild, pre);
    }
}

void CreateThread(ThreadTree T) {
    ThreadTree pre = NULL;
    if(T!= NULL) {
        Inthread(T, pre);
        pre->rchild = NULL; // 最后一个节点的右指针置空
        pre->rtag = 1;      // 最后一个节点的右指针标记为1
    }
}
```

中序线索二叉树构造类似于中序遍历，只是将==访问当前结点==改成==线索化==

用快慢指针的思想，pre指针指向上一个结点，记录前驱，p指向pre的后继。

3. 中序线索二叉树的遍历：

先找到序列的第一个结点 -> 找该结点的后继直到后继为空（==若右标志为1，右链就是线索指向后继，否则遍历右子树中最左下的结点==）

遍历算法如下：

```c
//求第一个结点
ThreadNode *Firstnode(ThreadNode *p)
{
    while(p->ltag == 0)
        p = p->lchild;
    return p;
}
//求p的后继
ThreadNode *Nextnode(ThreadNode *p)
{
    if(p->rtag == 0)
        return Firstnode(p->rchild);
    else
        return p->rchild;
}
//调用
void Inorder(ThreadNode *T)
{
    for(ThreadNode *p = Firstnode(T); p!= NULL; p = Nextnode(p))
        printf("%d ", p->data);
    printf("\n");
}
```

[中序线索二叉树](https://github.com/Xiaoliangya/C_DS/blob/master/ThreadTree.cpp)

4. 先序后序

​	先序只需要调整vist内容即可，后序比较复杂，赌他不考

### 4.4 树和森林

#### 4.4.1 树的存储结构

1. 双亲表示法：用一组连续的空间来存储每个结点，同时每个结点增设一个伪指针，指示双亲结点在数组中的位置。

<img src="https://i-blog.csdnimg.cn/blog_migrate/81964eebac334c8ec152efcf79c245f5.png#pic_center" alt="一棵树" style="zoom:50%;" />

<img src="https://i-blog.csdnimg.cn/blog_migrate/07ea0619aa3a68db30939d077a1c6230.png#pic_center" alt="双亲表示法" style="zoom: 67%;" />

```c
#define MAX_SIZE 100
typedef struct {
    int data;
    int parent;
}PTNode;

typedef struct{
    PTNode nodes[MAX_SIZE];
    int n;
}PTree;
```

该方法找双亲容易，但是找孩子结点需要遍历整个结构。

2. 孩子表示法

将每个孩子结点视为一个线性表，且以单链表作为存储结构，则n个结点就有n个孩子链表（叶结点的孩子链表为空表），且n个头指针也组成一个线性表

<img src="https://i-blog.csdnimg.cn/blog_migrate/6fcae292db639c86d992569b497c97c2.png#pic_center" alt="孩子表示法" style="zoom:50%;" />

3. 孩子兄弟表示法

也叫做二叉树表示法，简单的说==左孩子右兄弟==

#### 4.4.2 树、森林和二叉树的转换

1. 树->二叉树 `左孩子右兄弟`
2. 森林转成二叉树 `左孩子右兄弟`
3. 二叉树->森林 `断开右链直到没有右子树`  得到的森林唯一

#### 4.4.3 树和森林的遍历

1. 树的遍历：
   1. 先根遍历：先根节点->子树
   2. 后根遍历：子树->根结点
2. 森林的遍历：
   1. 先序：访问森林中第一棵树的结点->先序遍历第一棵树中根节点的子树森林->下一颗树
   2. 中序：中序遍历第一棵树中根节点的子树森林->访问森林中第一棵树的结点->下一颗树

|  树  | 森林 | 二叉树 |
| :--: | :--: | :----: |
| 先根 | 先序 |  先序  |
| 后根 | 中序 |  中序  |

### 4.5 应用

#### 4.5.1 哈夫曼树和哈夫曼编码

1. 定义：

* 路径：从一个结点到另一个结点之间的分支

* 路径长度：分支数目（边的条数）

* 权：树中结点常被赋予一个某种意义的值

* 带权路径长度：从树的根到一个结点的路径长度与该结点的权值乘积
  $$
  WPL = ∑w~i~*l~i~
  $$

* ==哈夫曼树==：也是最优二叉树--WPL最小的二叉树

2. 构造：每次选择两个权值最小的结点构造出新的结点，权值是其和（n个结点构造完成后共有2n-1个结点，且不存在度为1的结点）

3. 哈夫曼编码：
   * 前缀编码：若没有一个编码是另一个编码的前缀，就是前缀编码
   * 可以用左0右1来编码

#### 4.5.2 并查集

并查集用于处理没有重复元素的集合合并以及查询问题

1. 并查集支持以下3种操作：
   * Initial(S)：将集合S中的每个元素都初始化为只有一个单元素的子集合
   * Union(S，root1，root2)：将集合S中的子集和root2并入 root1。要求root1和root2互不相交
   * Find(S，x)查找集合S中单元素所在的子集和，返回其根结点
2. 存储结构：

<img src="https://i-blog.csdnimg.cn/blog_migrate/6c80d28f0f68538e68df2a1a4641f7e1.png" alt="并查集" style="zoom:50%;" />

合并两个子集只需要将其中一个子集合根结点的双亲指针指向另一个集合的根结点

3. 基本实现：

```c
void Initial(int S[])
{
    for(int i=0;i<SIZE;i++)
        S[i]=-1;
}

int Find(int S[],int x)
{
    int root=x;
    while(S[root]>=0)
        root=S[root];
    while(x!=root)
    {
        int temp=S[x];
        S[x]=root;
        x=temp;
    }
    return root;
}

void Union(int S[],int root1,int root2)
{
    if(root1==root2)
        return;
    if(S[root2]>S[root1])
    {
        S[root1]+=S[root2];
        S[root2]=root1;
    }else{
        S[root2]+=S[root1];
        S[root1]=root2;
    }
}
```

## 5 图

### 5.0 考纲内容

* 图的概念
* 图的存储和基本操作
* 图的遍历
* 图的应用

### 5.1 图的基本概念

#### 5.1.1 图的定义

​	图G包括==顶点集V==和==边集E==，记`G=（V，E）`，其中V(G)表示图中顶点的有限非空集；E(G)表示图G中顶点之间关系(边)的集合。

​	若V = {v1、v2……vn}，用|V|表示图G中顶点个数，E = {(u,v)|u∈V,v∈V}，用|E|表示图G中边的条数，图必须至少有一个顶点

1. 有向图：<v, w>，v是弧尾，w是弧头，表示从v到w的弧，也叫v邻接到w

2. 无向图：（v，w）边依附于v、w

3. 简单图、多重图：

   * 简单图：不存在重复边、不存在顶点到自身的边

4. 完全图：在任意两个顶点之间都存在边

5. 子图：有两个图G和G~1~，如果G~1~的顶点集和边集都是G的子集，则G~1~是G的子图，并且V(G~1~)=V(G)，则G~1~是G的生成子图

   * 生成子图：G~1~和G的区别是边不同，顶点一样

6. ==连通、连通分量、连通图==（针对无向图而言）：

   * 连通：无向图中，若顶点v到顶点w有路径存在，则称v和w是连通的。

   * 连通图：图中任意两个顶点都是连通的，则称图G为连通图

   * 连通分量：无向图中的==极大连通子图（不被任何一个连通子图包含）==称为连通分量

   * 连通子图：子图+连通

     ` 完全图一定是连通图，但连通图不一定是完全图。`  	路径不等于边

7. ==强连通图、强连通分量==（针对有向图而言）：

   * 强连通：顶点v->w,顶点w->v之间都有路径。
   * 强连通图：任意一对顶点都是强连通的，就是强连通图
   * 强连通分量：极大强连通子图

8. 生成树、生成森林

   * 连通图的生成树是包含图的全部顶点的一个极小连通子图（去点一条边就是非连通图，加上一条边就会形成回路

9. 顶点的度、入度、出度：==度==是指依附于顶点v的边的条数（无向图的度是边的两倍）

   ​					  ==入度==是有向图中以v为终点的有向边的条数，==出度==是以v为起点的边的条数，度=入度+出度

10. 边的权和网：边带权值--图称带权图、网

11. 稠密图、稀疏图：边的数目多少

12. 路径、路径长度和回路：路径是指顶点序列，路径长度是边的条数，回路是指第一个和最后一个顶点相同的路径

13. 简单路径：顶点不重复出现的路径就是简单路径；简单回路：除第一个顶点和最后一个顶点外其他顶点不重复出现的回路

14. 距离：从顶点u到顶点v的最短路径若存在，该路径长度就是u到v的距离

15. 有向树：一个顶点的入度为0，其他顶点的入度为1的有向图称为有向树

### 5.2 图的存储及基本操作

#### 5.2.1  邻接矩阵法

* 一维数组用来存储顶点信息，二维数组用来存储边的信息（邻接矩阵）

​	A[i] [j] = 1 表示（v~i~，v~j~）或<v~i~，v~j~>是G的边，如果是带权图，则将1设置为w~ij~

```c
//邻接矩阵
#define MaxVertexNum 100
typedef char VertexType; //顶点类型
typedef int EdgeType; //边的权值类型

typedef struct {
    VertexType vex[MaxVertexNum]; //顶点数组
    EdgeType edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵
    int vertexNum, edgeNum; //图的顶点数和边数
}MGraph;
```

* 简单应用中，可以直接用二维数组
* 无向图的邻接矩阵可以用压缩存储（对称），无向图的邻接矩阵第i行或者第i列非零元素的个数就是该顶点的度
* 有向图的邻接矩阵，i行是出度，i列是入度
* A^n^表示i-j的长度为n的路径的数目

#### 5.2.2 邻接表法

每一个顶点v~i~都建立一个单链表，第i个单链表中的结点表示依附顶点v~i~的边（对于有向图则是以顶点v~i~为尾的弧），单链表就称为v~i~的边表

边表的头指针和顶点的数据信息采用顺序存储，称为顶点表

* 顶点表结点：顶点域（data）存储顶点v~i~的相关信息，边表头指针域（firstarc）指向第一条边的边表结点
* 边表结点：邻接点域存储和v~i~邻接的顶点编号，指针域指向下一条边的边表结点

```c
#define MaxVertexNum 100
typedef struct ArcNode {
    int adjvex; //该弧所指向的顶点
    struct ArcNode *nextarc; //指向下一个弧的指针
}ArcNode;

typedef struct VNode {
    VertexType data; //顶点信息
    ArcNode *firstarc; //指向第一条依附该顶点的弧的指针
}VNode, AdjList[MaxVertexNum]; //邻接表

typedef struct {
    AdjList vertices; //邻接表
    int vexNum, arcNum; //图的顶点数
}ALGraph;
```

![邻接表](https://i-blog.csdnimg.cn/blog_migrate/d6b43cd5c786fef125b9b8d811b414d2.png)

[邻接法](https://github.com/xiaoliangao/C_DS/blob/master/Graph.cpp):邻接表查邻边，邻接矩阵查两点之间是否有边

#### 5.2.3 十字链表

是有向图的一种链式存储结构：由顶点结点和弧结点组成

* 顶点结点：

```
1、data:顶点数据域
2、firstin:入边单链表头指针
3、firstout:出边单链表头指针
```

* 弧结点：

```
1、tailvex:尾域，存放弧尾节点
2、headvex:头域，存放弧头节点
3、hlink:弧头相同的下一条边，即指向下一个边表节点的指针
4、tlink:弧尾相同的下一条边
5、info:权值
```

![十字链表](https://i-blog.csdnimg.cn/blog_migrate/ab145c7aab6476935dfc5e626929b509.jpeg)



#### 5.2.4 邻接多重表

* 顶点表节点：

```
1、data：顶点数据域
2、firstedge:边表节点的头指针
```

* 边表节点：

```
1、ivex:该边的第一个端点
2、ilink:与该端点相邻的下一个边表节点的指针
3、jvex:该边的第二个端点
4、jlink:与该端点相邻的下一个边表节点的指针
5、info:权值
```

#### 5.2.5 图的总结

|              |      邻接矩阵      |     邻接表     | 十字链表 | 邻接多重表 |
| :----------: | :----------------: | :------------: | :------: | :--------: |
|  空间复杂度  |        V^2^        |    V+2E/V+E    |   V+E    |    V+E     |
|   找相邻边   |         V          | 遍历整个邻接表 |   方便   |    方便    |
| 删除边或顶点 | 删除边方便，顶点难 |  无向图不方便  |   方便   |    方便    |
|    适用于    |        稠密        |      稀疏      |  有向图  |   无向图   |
|   表示方式   |        唯一        |     不唯一     |  不唯一  |   不唯一   |

### 5.3 图的遍历

主要是[广度和深度优先](https://github.com/xiaoliangao/C_DS/blob/master/Graph_visited.cpp)两种

#### 5.3.1 广度优先

从顶点v开始依次访问v的各个未访问的邻接顶点w1、w2、w3……wi然后从这些顶点出发访问其未访问过的邻接顶点

```c
//BFS的伪代码
bool visited[max_vertx_num];
void BFSTraverse(Graph G){
    for(int i=0; i<G.vexnum; ++i){
        visited[i] = flase;//初始化访问数组
    }
    InitQueue(Q)；
    for(int i=0; i<G.vexnum; ++i){
        if(!visited[i]){
            BFS(G,i)
        }
    }
}
```

* 基于邻接表的的BFS

```c
void BFS(ALGraph G, int i)
{
    visit(i); //访问顶点v
    visited[i] = true; //访问数组设为true，表示已经访问
    EnQueue(Q,i)  //将顶点i入队
    while (!IsEmpty(Q)) //队列非空
    {
        DeQueue(Q,v); //队首结点出队，依次访问该顶点的邻接顶点
        for(p = G.vertices[v].firstarc;p;p=p->nextarc){ //p指向顶点i的第一条邻接边
            w = p ->adjvex; //w是该边指向的顶点
            if(visited[w]==false){ //未访问，访问且入队
                visit(w);
                visited[w] = true;
                EnQueue(Q,w);
            }
        }
    }
}
```

* 基于邻接矩阵的BFS

```c
void BFS(MGraph G,int i)
{
    visit(i);
    visited[i] = True;
    EnQueue(Q,i);
    while(!IsEmpty(Q)){
        DeQueue(Q,v);
        for(w=0;w<G.vexnum;w++){   //检测v的所有邻接点
        	if(visited[w]=false&&G.edge[v] [w]==1){  //顶点w未访问，且v、w之间有边
                visit[w];
                visited[w] = true;
                EnQueue(Q,w);
            }
        }
    }
}
```

1. BFS的性能分析

​	需要一个辅助队列Q，n个顶点均需要入队一次

​	邻接表：时间复杂度是==O(V+E)==，每个顶点和边都需要访问一次

​	邻接矩阵：时间复杂度是==O(V^2^)==

2. BFS用于求解单源最短路径问题

​	对于非带权图G(V,E)，定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路径中最少的边数，若不存在，则是∞

```c
void BFS_MIN_Distance(Graph G,int u){
    for(int i = 0; i < G.vexnum; i++){
        d[i]=∞;   //初始化路径长度
    }
    visited[u]=true;d[u]=0;//从u开始到目标终点
    EnQueue(Q,u);
    while(!IsEmpty(Q)){
        DeQueue(Q,u){
            for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w)){
                if(!visited[w]){
                    visited[w]=true;
                    d[w]=d[u]+1;
                    EnQueue(Q,w);
                }
            }
    }
}
```

3. 广度优先生成树

​	在广度遍历的过程中，我们可以得到一颗遍历树，称为广度优先生成树

​	邻接表不唯一，得到的生成树也不唯一；邻接矩阵唯一，得到的生成树也唯一

#### 5.3.2 深度优先

访问一顶点v，然后由v出发，访问与v邻接但是未被访问的任一顶点w~1~，在访问w~1~的邻接且未被访问的顶点……（用栈）

```c
bool visited[MAX_VERTEX_NUM];
void DFSTraverse(Graph G){
    for(i=0;i<G,vexnum;i++){
        visited[i]=FALSE;
    }
    for(i=0;i<G.vexnum;i++){
        if(!visited[i]){
            DFS(G,i)
        }
    }
}
```

* 基于邻接表

```c
void DFS(ALGraph G, int i){
    visit(i);
    visited[i]=true;
    for(p=G.vertices[i].firstarc;p;p=p->nextarc){
        j=p->adjvex;
        if(visited[j]=FALSE){
            DFS(G,J);
        }
    }
}
```

* 基于邻接矩阵

```c
void DFS(MGraph G,int i){
    visit(i);
    visited[i]=true;
    for(int j=0;j<G.vexnum;j++){
        if(visited[j]==false&&G.edge[i][j]==1){
            DFS(G,j)；
        }
    }
}
```

深度优先的遍历过程：需要借助栈来实现，将每次访问的结点入栈，一直到该结点没有邻接结点未访问则出栈。

1. 算法性能分析：空间复杂度O(V);时间复杂度O(V^2^)/O(V+E)
2. 深度优先的生成树和生成森林

### 5.4 图的应用

#### 5.4.1 最小生成树

G的最小生成树是权值最小的那颗生成树（极小连通子图）

* 性质：
  * 有权值相同的边则可能不唯一，但是权值互不相等时，最小生成树是唯一的；若无向连通图G的边数比顶点数少1，即G本身是一颗树时，G的最小生成树就是本身。
  * 虽然最小生成树不唯一，但是对应的边的权值之和总是唯一的，且是最小的，但是不能保证是最短路径
  * 最小生成树的边数为定点数减一

通用的最小生成树算法：

```c
GENERIC_MST(G){
    T=NULL;
    while T //未形成一颗生成树
        do //找到一条代价最小的边且加入T后不会产生回路
            T=T∪(u,v);
}
```

* Prim算法

从某个顶点开始，每次选择一个与当前T中顶点集合距离最近的顶点加入T

```c
int Prim(int cur) {//选择起始点
    int index = cur;
    int sum = 0;
    int i = 0;
    int j = 0;
    cout << index << " ";//输出index可以输出路径
    memset(book, false, sizeof(book));//初始化
    book[cur] = true;//标记初始点
    for (; i < N; ++i)
        dist[i] = graph[cur][i];//初始化，并令每个与cur点邻接点的距离存入dist
    for (i = 1; i < N; ++i) {
        int minor = INF;
        for (j = 0; j < N; ++j) {//找到与index相接的最短路径
            if (!book[j] && dist[j] < minor) {
                minor = dist[j];
                index = j;
            }
        }
        book[index] = true;
        cout << index << " ";
        sum += minor;
        for (j = 0; j < N; ++j) {//重新初始化dist，找到与index邻接的点
            if (!book[j] && dist[j] > graph[index][j])
                dist[j] = graph[index][j];
        }
    }
    cout << endl;
    return sum;//返回最小生成树的总路径值
}
```

2. Kruskal算法

每次都选择权值最小的边

```c
int Kruskal(int n) {
    int sum = 0;
    make_set();
    for (int i = 0; i < N; ++i) {
        if (find_set(V[i].start) != find_set(V[i].end)) {
            Union(V[i].start, V[i].end);
            sum += V[i].val;
        }
    }
    return sum;
}
```

#### 5.4.2 最短路径

1. Dijkstra算法：

   * 每次从未标记的节点中选择与出发点最近的点，标记。

   * 计算第一步刚加入的节点 A 的邻近节点 B 的距离。如果节点A 到出发点的距离 + A 到 B 的距离 < 节点 B 的当前值，则更新 B 的距离。

2. Floyd算法：解决任意两点间的最短路径的一种算法

   * Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。
   * [算法执行演示](https://blog.csdn.net/jeffleo/article/details/53349825)

```java
private void floyd() {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = Math.min(a[i][j], a[i][k] + a[k][j]);
            }
        }
    }

    // 打印
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            System.out.println(i + " " + j + ":" + a[i][j]);
        }
    }
}
```

* `初始化->将v0作为中间顶点->v1->……`

总结：

|            | BFS            | Dijkstra       | Floyd                |
| ---------- | -------------- | -------------- | -------------------- |
| 用途       | 求单源最短路径 | 求单源最短路径 | 各顶点之间的最短路径 |
| 无权图     | 适用           | 适用           | 适用                 |
| 有权图     | 不适用         | 适用           | 适用                 |
| 带负权值   | 不适用         | 不适用         | 适用                 |
| 带负权回路 | 不适用         | 不适用         | 不适用               |
| 时间复杂度 | O(V^2^)/O(V+E) | O(V^2^)        | O(V^3^)              |

#### 5.4.3 有向无环图表达式

![youxiangtuhuantu](https://img2020.cnblogs.com/blog/1781524/202006/1781524-20200630141723410-1332544194.png)

![1](https://img2020.cnblogs.com/blog/1781524/202006/1781524-20200630141735629-1277642890.png)

#### 5.4.4 拓扑排序

由一个有向无环图的顶点组成的序列，能满足以下条件就是拓扑排序：

* 每个顶点有且仅出现一次
* 若顶点A在顶点B前面，则图中不存在从B到A的路径

拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到B的路径，则在排序中B出现在A的后面。每个AOV网都有一个或多个拓扑排序序列

* 求拓扑排序步骤：
  * 从AOV网中选一个没有前驱（入度为0）的顶点并输出
  * 从网中删除该顶点和所有以它为起点的有向边
  * 重复1、2直到AOV网为空或者当前网中不存在无前驱的顶点为止。（后一种情况说明有向图中必定有环）

```c
bool TopologicalSort(Graph G){
    InitStack(S);  //初始化栈，存储入度为0的顶点
    int i;    //结点编号
    for(i=0;i<G,vexnum;i++){
        if(indegree[i]==0){
            Push(S,i);    //将入度为0的结点入栈
        }
    }
    int count = 0;  //计数记录当前已经输出的顶点数
    while(!IsEmpty(S)){      //栈不空说明还有入度为0的顶点
        Pop(S,i);			//栈顶元素出栈
        print[count++]=i;	//输出顶点i
        for(p=G,vertices[i].firstarc;p;p=p->nextarc){
            //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S
            v=p->adjvex;	
            if(!(--indegree[v]))
                Push(S,v);  //入度为0则入栈
        }
    }
    if(count<G.vexnum)  //如果count=vexnum则有回路
        return false;
    else
        return true;
}
```

* DFS也可以实现拓扑排序：对于有向无环图G中的任意结点u、v一定存在下面3种关系
  * u是v的祖先，则在调用BFS访问u之前，一定对v进行了DFS访问，即v的DFS结束时间先于u的DFS结束时间从而可以考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。祖先的结束时间远大于子孙。
  * 若u是v的子孙，同上
  * u、v没有关系，序列任意
* 逆拓扑排序：
  * 从AOV网中选择一个没有后继的的顶点输出
  * 删除以其为终点的有向边
  * 重复1、2
* 拓扑排序序列唯一：每次入度为0的结点唯一则唯一

#### 5.4.5 关键路径

* AOV网—用顶点表示活动
* AOE网—用边表示活动

* 关键路径：具有最大长度的路径、关键活动：关键路径上的活动

![1](https://i-blog.csdnimg.cn/blog_migrate/afacc3cfa6b7e10fcb3e2f87547d2f6b.png#pic_center)

| 顶点 | ve[i] | vl[i] | vl[i]-ve[i] |
| :--: | :---: | :---: | :---------: |
|  1   |   0   |   0   |      0      |
|  2   |   6   |   6   |      0      |
|  3   |   4   |   6   |      2      |
|  4   |   5   |   8   |      3      |
|  5   |   7   |   7   |      0      |
|  6   |   7   |  10   |      3      |
|  7   |  16   |  16   |      0      |
|  8   |  14   |  14   |      0      |
|  9   |  18   |  18   |             |

* 还可以根据a~i~来求
  * 弧的最早开始时间e()等于起点的顶点的v~e~()
  * 最迟等于终点的v~l~()减去弧的持续时间
  * l(i)-e(i)=0的就是关键活动

## 6 查找

### 6.0 考纲内容

* 查找的概念
* 顺序查找
* 分块查找
* 折半查找
* 树形查找
* B树、B+树
* 散列表
* 查找算法的分析和应用

### 6.1 顺序查找和折半查找

1. 顺序查找（线性查找）：

```c
typedef struct{
    int *elem;
    int TableLen;
}SSTable;

int Search_Seq(SSTable ST,int key)
{
    ST.elem[0] = key;
    int i;
    for(i=ST.TableLen;ST.elem[i]!=key;i--);
    return i;
}
```

* ST.elem[0]作为哨兵的作用是使得Search_Seq内的循环不必判断数组是否越界。从尾部开始查找，要么返回i，要么返回0。
* 如果线性表的关键字是有序的就可以用判定树来描述查找过程。（n个结点，相应地由n+1个查找失败结点）
  * `ASL=n/2+n/(n+1)`

2. 折半查找（二分查找）：

```c
int Binary_Search(SSTable ST,int key)
{
    int low = 0, high = ST.TableLen - 1, mid;
    while(low<=high){
        mid=(low+high)/2;
        if(ST.elem[mid]==key)
            return mid;
        else if(ST.elem[mid]<key)
            low=mid+1;
        else
            high=mid-1;
    }
    return -1;
}
```

* 折半查找查找过程用二叉树来描述，称为判定树，一定是平衡二叉树。`ASL=(n+1)/n log2(n+1)-1`

3. 分块查找（索引顺序查找）：

* 块内无序、块间有序（每个块中最大关键字小于第二个块中所有关键字）；索引表由块内最大关键字和各块中第一个元素地址组成
  * `ASL=L1+LS=(b+1)/2+(s+1)/2`

### 6.2 树形查找

#### 6.2.1 二叉排序树(BST)

二叉排序树是为了更好的提高查找、插入、删除的速度

1. 定义：二叉排序树（二叉查找树）满足（左<根<右）；如果根据中序遍历，会得到一个递增序列
2. 二叉排序树的查找：从根结点开始，沿着某个分支逐层向下比较的过程，若二叉树非空，先和根结点比较，再和孩子结点比较

```c
BSTNODE *BST_Search(BiTree T,ElemType key){
    while(T!=NULL&&key!=T->data){
        if(key<T->data)
            T=T->lchild;
        else
            T=T->rchild;
    }
    return T;
}
```

3. 二叉排序树的插入：

   * 若二叉排序树为空，则直接插入
   * k小于根结点值，插入左子树
   * k大于根结点值，插入右子树

      ！插入的结点一定是查找失败时的查找路径上访问的最后一个结点的左孩子或者右孩子

```c
int BST_insert(BiTree &T,KeyType k){
    if(T==NULL){
        T=(BiTree)malloc(sizeof(BSTNode));
        T->data=k;
        T->lchild=T->rchild=NULL;
        return 1;
    }
    else if(k==T->data)	
        return 0;
    else if(k<T->data)
        return BST_insert(T->lchild,k);
    else
        return BST_insert(T->rchild,k);
}
```

4. 二叉排序树的构造

```c
void Creat_BST(BiTree &T,KeyType str[],int n){
    T=NULL;
    int i = 0;
    while(i<n){
        BST_Insert(T,str[i]);
        i++;
    }
}
```

5. ==二叉树的删除==
   * 叶结点直接删除
   * 若z只有左子树或右子树，则直接让z的子树成为z父节点的子树
   * 若结点z有左右两棵子树，则令z的直接前驱(直接后继)代替z，然后从二叉排序树中删去直接前驱(直接后继)，转成第一或第二种情况

![删除](https://i-blog.csdnimg.cn/blog_migrate/9230d0910cc24dd7e28410a27995d464.png)



6. 查找效率分析：主要取决于树的高度—平衡二叉树，平均查找长度O(log~2~n)；只有左（右）孩子的单支树，平均查找长度O(n)

#### 6.2.2 平衡二叉树

1. 定义：任意结点的左子树和右子树的高度差的绝对值不超过1，也叫AVL树，结点的高度差称为该结点的平衡因子（平衡二叉树的结点的平衡因子值只能是1、0、-1）

2. 平衡二叉树的插入：

   * LL-右单旋转

   ![LL](https://i-blog.csdnimg.cn/blog_migrate/a590ffb4d711fad09142da008e3b8fb5.png)

   * RR-左单旋转

   ![rr](https://i-blog.csdnimg.cn/blog_migrate/e2d9c664248df1616863e2b9af4d80b8.png)

   * LR-先左后右双旋转

   ![lr](https://i-blog.csdnimg.cn/blog_migrate/bcdd61db0be86bbafa0a090fb7c8392d.png)

   * RL-先右后左双旋转

   ![rl](https://i-blog.csdnimg.cn/blog_migrate/5077a66a5899550fa6cb11803f023feb.png)

3. 平衡二叉树的删除：用插入的方法删除
4. 平衡二叉树的查找：
   * n~h~=n~h-1~+n~h-2~+1(高度为h的AVL树的结点是高度为h-1的结点+高度是h-2的结点数+1)
   * 具有==n个结点的平衡二叉树的最大深度为O(log~2~n)==

#### 6.2.3 红黑树

1. 定义：红黑树是满足如下红黑性质的二叉排序树：
   * 结点是红色或者黑色
   * 根结点一定是黑色的
   * ==叶结点(虚拟的外部结点、NULL结点)都是黑的==引入了n+1个外部叶结点
   * 不存在两个相邻的红结点(红结点的父节点孩子节点都是黑的)
   * ==对于每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同==
   * ==左根右(大小)；根叶黑；不红红；黑路同==

* 从根到叶结点的最大路径不大于最短路径的两倍 -- 黑高=最短路径长度
* 有n个内部结点的红黑树的高度h<=2log~2~(n+1)

2. 红黑树的插入
   * ==红黑树中新插入的结点着色为红色==,如果是根就染为黑色
   * 满足定义，则插入结束
   * 不满足就需要调整使得满足红黑树定义
     * 黑叔：旋转加染色a
     * 红叔：染色加变新(叔父爷染色，爷变为新结点)

### 6.3  B树和B+树

#### 6.3.1 B树及其基本操作

m阶B树是所有结点的平衡因子均等于0的m路平衡二叉树

特点：

* 每个结点最多有m颗子树，即至多有m-1个关键字
* 若根结点不是叶结点，则至少有2棵子树，即至少有一个关键字
* 除根结点外的所有非叶结点至少有「m/2⌉，则至少有「m/2⌉-1个关键字

![1](https://i-blog.csdnimg.cn/blog_migrate/c07d8f88a3d2ab239c8e8b851f4bd926.png)

p~i-1~所指子树中所有结点的关键字均小于K~i~，p~i~所指子树中所有节点的关键字均大于K~i~

* 所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的失败结点，实际上并不存在）

![1](https://i-blog.csdnimg.cn/blog_migrate/2c62ff567de36fae8e0de9272019f8b2.png)

* 结点的孩子个数=该结点中关键字个数+1
* 根结点没有关键字就没有子树，B树此时为空；有关键字就一定大于等于2
* 除根结点外所有非叶节点至少有「m/2⌉
* 结点中关键字从左到右递增有序

1. B树的查找：在B树中查找结点->在结点内找关键字（B树常存储在磁盘中，在磁盘中查结点、在内存中找关键字）

2. B树的高度(磁盘读取次数)：不包括叶结点

   * 最多h>=log~m~(n+1)
   * 最少h<=log~「m/2⌉~((n+1)/2)+1

3. ==B树的插入==：若溢出则分裂==左部分放入原结点，中间位置放入父节点，右部分放入新结点==

4. ==B树的删除==：

   * 不在终端结点，用前驱或者后继替代->转换成删除终端结点

   * 在终端结点：

     * 直接删除(原关键字个数>=「m/2⌉)
     * 兄弟够借：向兄弟借一个，不是直接拿过去，而是带着父结点的关键字一起旋转一下

     ![1](https://i-blog.csdnimg.cn/blog_migrate/fde25bef7cbecdc3cb57552ce10dc040.png#pic_center)

     * 兄弟不够借：与兄弟合并，并且带着父结点的关键字一起合并

     ![1](https://i-blog.csdnimg.cn/blog_migrate/8815d5381ecd4e6cea29db9695e7164a.png#pic_center)

#### 6.3.2 B+树

m阶B+树的特点：

* 每个分支结点最多有m棵子树
* 非叶根结点至少有两棵子树，其他每个分支结点至少有⌈m/2⌉棵子树
* ==结点的子树个数和关键字个数相等==
* 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻结点按大小顺序链接起来(支持顺序查找)
* 所有分支结点(可视为索引的索引)中仅包含他的各个子结点(下一级的索引块)中关键字的最大值及指向其子结点的指针

==m阶B树和m阶B+树的差异==

* 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；B树是含有n个关键字的结点有n+1棵子树
* 在B+树中，每个结点(非根内部结点)的关键字个数n的范围是⌈m/2⌉<=n<=m(非叶根结点：2<=n<=m)；在B树中，每个结点的关键字个数n的范围是⌈m/2⌉-1<=n<=m-1(根结点：1<=n<=m-1)
* 在B+树中，叶结点包含了全部关键字，非叶节点中出现的关键字也会出现在叶结点中；而在B树中最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。

* B +树中的叶节点包含信息，非叶节点仅仅起到索引作用，当我们在查询的时候，不管是成功还是失败，最终都会找到叶节点所在的层次，查找的时间复杂度相对稳定。而B树中的所有结点都记录有信息（存储地址，指针等），查找到目标关键字后，不会继续向下查询，所以时间复杂度相对不稳定。
* B +树中，用一个指针指向关键字最小的叶节点，将所有叶节点串成一个相信链表。

==B+树中，无论查找成功与否，都是从根结点到叶结点的路径==

![1](https://i-blog.csdnimg.cn/blog_migrate/d19a961fb17ca1d6d47b95daef0f2c64.png)

### 6.4 散列表(hash表)

#### 6.4.1 基本概念

* 散列函数：也叫哈希函数，一个将查找表中关键字映射成该关键字对应的地址的函数
* 散列表：建立了关键字和存储地址之间的一种直接映射关系
  * 冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，而这些发生冲突的不同关键字称为同义词

#### 6.4.2 散列函数的构造方法

* 散列函数的定义域必须包括全部关键字，而值域的范围则依赖于散列表的大小

* 要尽可能减少冲突

* 要尽量简单

1. 直接定址法：直接取关键字的某个线性函数值为散列地址，散列函数为`H(key)=key或H(key)=a*key+b`
2. ==除留余数法==：假设表长为m，取一个不大于m但接近或等于m的质数p，散列函数为`H(key)=key%p`

![1](https://i-blog.csdnimg.cn/blog_migrate/b2111dd01c06fb9b0bd70ab563440ade.png)

3. 数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址

![1](https://i-blog.csdnimg.cn/blog_migrate/dfee9bf3f1f89cb028be9de93b376b58.png)

4. 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定

#### 6.4.3 [处理冲突的方法](https://blog.csdn.net/weixin_44162361/article/details/121520338)

1. 开放地址法：是指表中可存放新表项的空闲地址既向他的同义词开放，又向非同义词开放`H~i~=(H(key)+d~i~)%m`
   1. 线性探测法：d~i~=1，2，3，……，m-1
   2. 平方探测法：d~i~=1^2^，-1^2^，2^2^，…
   3. 双散列法：H~i~=(H(key)+i*Hash~2~(key))%m
   4. 伪随机序列法
2. 拉链法:
3. 例如，关键字序列为{12，15，16，22 ，25，29，34，37，47，48，56，67} ，散列函数为Hash( key ) = key % 13 
   <img src="https://i-blog.csdnimg.cn/blog_migrate/1c6d0020b5132efc2af137959b3da02e.png" alt="1" style="zoom:33%;" />

#### 6.4.4 性能分析

`{19,14,23,01,68,20,84,27,55,11,10,79}；H(key)=key%13`（采用线性探测法）

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 14   | 01   | 68   | 27   | 55   | 19   | 20   | 84   | 79   | 23   | 11   | 10   |      |      |      |
|      | 1    | 2    | 1    | 4    | 3    | 1    | 1    | 3    | 9    | 1    | 1    | 3    |      |      |      |

​	ASL~成功~=（1*6+2+3*3+4+9）/12=2.5

* ==装填因子==，表中记录数n/散列表长度m=α

## 7 排序

### 7.0 考纲内容

* 排序的基本概念
* 插入排序--直接插入、折半插入、希尔
* 交换排序--冒泡排序、快速排序
* 选择排序--简单选择、堆排序
* 二路归并
* 基数
* 外部排序
* 排序算法的分析和应用

### 7.1 排序的基本概念

定义：重新排序表中的元素使得其满足关键字有序

==稳定性==：对于两个关键字相同的元素，排序之后保持相对顺序不变就是稳定的

==内部排序==：关键字都在内存中、==外部排序==：关键字无法都存在内存中，排序过程中需要不断交换内存、外存中的数据

### 7.2 插入排序

#### 7.2.1 直接插入排序

要将元素L(i)插入已经有序的子序列L[1…i-1]的操作如下：

1. 查找出L(i)应该插入的位置k
2. 将L[k…i-1]依次后移
3. 将L[i]复制到L[k]

==可以像查找一样将L[0]置为哨兵==

```c
void direct_insert_sort(int arr[], int n)
{
    int i, j;
    for (i = 2; i <= n; i++)
    {
        if (arr[i] < arr[i - 1])
        {
            arr[0] = arr[i];
            for (j = i - 1; arr[0] < arr[j]; --j)
            {
                arr[j + 1] = arr[j];
            }
            arr[j + 1] = arr[0];
        }
    }
}
```

<img src="https://i-blog.csdnimg.cn/blog_migrate/4e9085c78edb1fdee471165b19e0cc05.gif" alt="1" style="zoom:50%;" />

==性能分析==：

空间效率：O(1)，哨兵

时间效率：最好是O(n)，最差、平均是O(n^2^)

适用于线性表，并且是==稳定==的排序算法

#### 7.2.2 折半插入排序

用折半查找来确定插入位置

```c
void binary_insert_sort(int arr[], int n)
{
    int i, j, low, high, mid;
    for(i = 2; i <= n; i++)
    {
        arr[0] = arr[i];
        low = 1;
        high = i - 1;
        while(low <= high){
            mid = (low + high) / 2;
            if(arr[mid]>arr[0])
                high = mid - 1;
            else
                low = mid + 1;
        }
        for(j = i - 1; j >= high + 1; --j)
            arr[j + 1] = arr[j];
        arr[high + 1] = arr[0];
    }
}
```

时间复杂度：比较次数是O(nlog~2~n)，但是总的时间复杂度仍是O(n^2^),==稳定==的排序算法，仅适用于顺序存储的线性表

#### 7.2.3 希尔排序

希尔排序的思想是：

* 先选定一个整数gap，把待排序文件中所有记录分成gap个组，所有距离为gap的记录分在同一组内，并对每一组内的元素进行排序。

* 然后将gap逐渐减小重复上述分组和排序的工作。

* 当到达gap=1时，所有元素在统一组内排好序。/也可以最后一趟进行直接插入排序

<img src="https://i-blog.csdnimg.cn/blog_migrate/420f5c5abac4bb459aaee2f95aaaf35f.gif" alt="1" style="zoom:50%;" />

```c
void Shell_sort(int arr[], int n)
{
    int dk, i, j;
    for(dk = n / 2; dk > 0; dk /= 2)
    {
        for(i = dk + 1; i <= n; ++i)
        {
            if(arr[i] < arr[i - dk])
            {
                arr[0] = arr[i];
                for(j = i-dk; j>0&&arr[0]<arr[j]; j=j-dk)
                {
                    arr[j+dk] = arr[j];
                }
                arr[j+dk] = arr[0];
            }
        }
    }
}
```

性能分析：

空间效率：O(1)

时间效率：最坏O(n^2^)

==不稳定==的排序算法，仅适用于顺序存储的线性表

### 7.3 交换排序

#### 7.3.1 冒泡排序

![1](https://i-blog.csdnimg.cn/blog_migrate/c13373922b3862f43cd7e444c78176aa.gif)

每一轮确定一个元素的最终位置。

```c
void BubbleSort(int arr[], int n)
{
    for(int i=0; i<n-1; i++)
    {	bool flag = false;
        for(int j=0; j<n-i-1; j++)//i是几就是确定了几个元素的位置
        {
            if(arr[j] > arr[j+1])
            {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                flag = true;
            }
        }
     if(!flag)
         return;
    }
}
```

1. 时间复杂度：O(n^2^)
2. 空间复杂度：O(1)
3. 稳定性：稳定

#### 7.3.2 快速排序

基本思想：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。

![1](https://i-blog.csdnimg.cn/blog_migrate/41634b27110105ad2f4ba59692e4dfec.gif)

```c
void QuickSort(int arr[], int low, int high)
{
    if(low < high)
    {
        int pivotpos = partition(arr, low, high);//根据得到的枢轴位置进行划分
        QuickSort(arr, low, pivotpos-1);
        QuickSort(arr, pivotpos+1, high);
    }
}

int partition(int arr[], int low, int high)
{
    int pivot = arr[low];
    while(low < high)
    {
        while(low < high && arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while(low < high && arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low] = pivot;
    return low;
}
```

性能分析：

空间效率：最好情况、平均情况--O(log~2~n)、最坏情况--O(n)

时间效率：O(nlog~2~n)

稳定性：不稳定

### 7.4 选择排序

每一趟（如第i趟）在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素就剩下一个不用选。

#### 7.4.1 简单选择排序

<img src="https://i-blog.csdnimg.cn/blog_migrate/be071b4b7b61a7d9b746b75d7ec3e0c7.gif" alt="1" style="zoom:33%;" />

```c
void SelectSort(int arr[], int n)
{
    for(int i=0; i<n-1; i++)
    {
        int min = i;
        for(int j=i+1; j<n; j++)
        {
            if(arr[j] < arr[min])
                min = j;
        }
        if(min!= i)
        {
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}
```

性能分析：

空间效率：O(1)

时间效率：O(n^2^)

稳定性：不稳定

适用于链表顺序表

#### 7.4.2 堆排序

<img src="https://i-blog.csdnimg.cn/blog_migrate/6b8296d2edd78b26f8ae4ba47e19cfb5.gif" alt="1" style="zoom: 50%;" />

堆的定义如下，n个关键字序列L[1…n]称为堆，当且仅当该序列满足：

* L(i)>=L(2i)且L(i)>=L(2i+1) 	大根堆（堆顶元素最大）
* L(i)<=L(2i)且L(i)<=L(2i+1)         小根堆（堆顶元素最小）

可以将堆视为一棵完全二叉树。

堆排序的思路（大根堆为例）：首先将存放在L[1…n]中的n个元素建成初始堆，输出堆顶元素后，将堆底（最后一个）元素送入堆顶，此时不满足堆的性质，，将堆顶元素向下进行调整，成为大根堆，再次输出堆顶元素。

* 建堆操作：每次都选择一个结点和他的孩子结点，选择一个满足条件的作为根结点，循环调整

```c
void BuildMaxHeap(int arr[], int n)
{
    for(int i=n/2; i>0; i--)
    {
        HeadAdjust(arr, i, n);
    }
}

void HeadAdjust(int arr[], int k, int n)
{
    arr[0] = arr[k];
    for(int i=2*k; i<=n; i*=2)
    {
        if(i<n && arr[i]<arr[i+1])//比较两个孩子节点大小
            i++;
        if(arr[0]>=arr[i])//比较根和较大的孩子结点
            break;
        else{
            arr[k] = arr[i];//交换
            k = i;
        }
    }
    arr[k] = arr[0];//空结点填入数据
}
```

堆排序算法

```c
void HeapSort(int arr[], int n)
{
    BuildMaxHeap(arr, n);
    for(int i=n; i>=2; i--){
        int temp = arr[1];
        arr[1] = arr[i];
        arr[i] = temp;
        HeadAdjust(arr, 1, i-1);
    }
}
```

### 7.5 归并排序、基数排序和计数排序

#### 7.5.1 归并排序

两两归并有序表并排序

<img src="https://i-blog.csdnimg.cn/blog_migrate/79510ba165786116c3a394cf6c4ee6f9.png" alt="2" style="zoom: 33%;" />

```c
int *B = (int *)malloc((n+1)*sizeof(int));

void merge(int A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k<=high;k++)
        B[k]=A[k];  //将A数组拷贝到B数组
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++)
        if(B[i]<=B[j])
            A[k]=B[i++];
        else
            A[k]=B[j++];
    while(i<=mid)
        A[k++]=B[i++];
    while(j<=high)
        A[k++]=B[j++];
}

void mergeSort(int A[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;
        mergeSort(A,low,mid);
        mergeSort(A,mid+1,high);
        merge(A,low,mid,high);
    }
}
```

<img src="https://i-blog.csdnimg.cn/blog_migrate/1c9517428afa0244546c0e08a8e7c3fe.gif" alt="1" style="zoom:53%;" />

**归并排序的特性总结：**

1.  归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。
2.  时间复杂度：O(N*logN)
3.  空间复杂度：O(N)
4.  稳定性：稳定

#### 7.5.2 基数排序

<img src="https://i-blog.csdnimg.cn/blog_migrate/44334fdcc9f1955aa35c242d2978dcdd.gif#pic_center" alt="·" style="zoom:50%;" />

稳定性：稳定

空间效率：O(r)

时间效率：O(d(n+r))

#### 7.5.3 计数排序

思想：

1. 统计相同元素出现次数
2. 根据统计的结果将序列回收到原来的序列中

输入数组A[n]，B[n]存放输出结果，C[n]存放计数值

```c
void CountSort(int A[],int B[],int n,int k){
    int i,C[k];
    for(i=0;i<k;i++)
        C[i]=0;
    for(i=0;i<n;i++)
        C[A[i]]++;
    for(i=1;i<k;i++)
        C[i]+=C[i-1];
    for(i=n-1;i>=0;i--){
        B[C[A[i]]-1]=A[i];
        C[A[i]]--;
    }
}
```

#### 总结

<img src="https://pic2.zhimg.com/80/v2-1a48925406e65655a6c42bcfa28df1cb_1440w.webp" alt="1" style="zoom:50%;" />

### 7.6 外部排序

#### 7.6.1 外部排序

概念：外存中的数据读入内存→在内存中排序→数据写入外存，外部排序通常采用归并排序

过程：生成初始归并段—>进行归并

1. 对于 r 个初始归并段进行 k 路归并，需要归并趟数 = log~k~r（向上取整，归并树高度）
2. 提升外部排序的速度、减少读写磁盘的速度的方法：提高 k 值，降低 r 值。

​	提高 r 值：增加归并段长度

​	但是，提高 k 有负面影响：

​	A.需要的缓存空间升高（k路归并需k个缓冲区）

​	B.内部归并的所需时间提高（选出最小关键字需要进行k - 1次比较）

#### 7.6.2 败者树

视为一颗完全二叉树，区别是在根节点之上多了一个胜者结点。

k个叶结点是当前参加比较的元素，非叶子结点用来记录左右子树中的“失败者”，胜者继续向上比较直到根结点 

![1](https://tse4-mm.cn.bing.net/th/id/OIP-C.J7tS0AHMtCTbR5gQc5cr6QHaDp?w=349&h=172&c=7&r=0&o=5&dpr=1.5&pid=1.7)

对于K路归并，只需要进行k-1次比较就能构建败者树；引进败者树后，选出最小的关键字，仅需⌈ log~2~k ⌉

#### 7.6.3 置换选择排序

<img src="https://github.com/xiaoliangao/C_DS/blob/master/%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg?raw=true" alt="1" style="zoom: 25%;" />  

#### 7.6.4 最佳归并树

构造成哈夫曼树





























